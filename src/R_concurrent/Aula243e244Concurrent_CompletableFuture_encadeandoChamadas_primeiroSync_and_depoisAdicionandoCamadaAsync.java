package R_concurrent;

// Quando existem mais de uma chamda a API's externas e etc, podemos encadear
// chamadas e adicionar camadas Async em métodos sincronizados.

// Aqui criamos o código por completo sem adicionar essa camada Async.


/* Desenho LowLevel da maneira Async:

        [main]                |           [Fork join]
                              |
                              | `supplyAsync`
           store Stream ------|-------------> getPricesSync (t1)
                              |                     |
                              |                     |  `thenApply`
                              |                     ↓
                              |              Quote::new Quote
                              |                     |
                              |                     |  `thenCompose`
                              |                     ↓
    price with discount<--join|--------------applyDiscount (t2)
                              |
*/

import R_concurrent.domain.Quote;
import R_concurrent.service.StoreServiceWithDiscount;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

public class Aula243e244Concurrent_CompletableFuture_encadeandoChamadas_primeiroSync_and_depoisAdicionandoCamadaAsync {
    private static List<String> storesList = List.of("Store 1", "Store 2", "Store 3", "Store 4");
    private static long start; // time para calcular ms da execução
    private static long end;

    public static void main(String[] args) {

        // searchPricesWithDiscountNotAsync();
        // Time passed using Not Async: 8074ms
        searchPricesWithDiscountWithAsync();
        // Time passed using WITH Async: 4096ms
    }

    private static void searchPricesWithDiscountNotAsync() {

        start = System.currentTimeMillis();

        storesList.stream()
                .map(StoreServiceWithDiscount::getPricesSync) // storeName:price:discountCode
                .map(Quote::newQuote)
                .map(StoreServiceWithDiscount::applyDiscount)
                .forEach(System.out::println);

        end = System.currentTimeMillis();
        System.out.printf("Time passed using Not Async: %dms%n", end - start);
    }

    private static void searchPricesWithDiscountWithAsync() {

        start = System.currentTimeMillis();

        List<CompletableFuture<String>> collect = storesList.stream()
                // Getting the price async of pattern storeName:price:discountCode
                .map(store -> CompletableFuture.supplyAsync(() -> StoreServiceWithDiscount.getPricesSync(store)))
                // Instantiating new Quote object sync from the string generated by getPricesSync(store)
                .map(cf -> cf.thenApply(Quote::newQuote))
                // Applying the discount async
                .map(cf -> cf.thenCompose(quote -> CompletableFuture.supplyAsync(() -> StoreServiceWithDiscount.applyDiscount(quote))))
                .collect(Collectors.toList());

        List<String> result = collect.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList());

        end = System.currentTimeMillis();
        System.out.println("Lista: "+result);
        System.out.printf("Time passed using WITH Async: %dms%n", end - start);
    }
}
