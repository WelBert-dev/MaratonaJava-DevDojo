-- Data - (Estudos feitos em Java e agora documentado)
-- link: -
-- Mais informações sobre serialização: -

- Fonte interessante com OverView:
https://www.devmedia.com.br/java-collections-como-utilizar-collections/18450

Intermediário: Mais específico no Java


/* Fluxograma Collections Framework Hierarchy in Java:
                     +----+----+
                    | Collection|                                     +---->   Map  <---+ Interface separada da hierarquia
                     +----+----+                                      |                 |
                          |                                 +---------+---------+-------+-------+
             +------------+-----------+                     |                   |               |
             |                        |                   HashMap          LinkedHashMap     TreeMap
           Set                      List                    |                   |               |
             |                        |                   Hashtable        IdentityHashMap   WeakHashMap
    +--------+-------+       +--------+-------+              |                                  |
    |                |       |                |           Properties                         SortedMap
 HashSet     SortedSet     ArrayList       LinkedList
    |                |            |          /      \
 LinkedHashSet  NavigableSet   Vector  DoublyLinkedList
                                             |
                                          Stack
                                             |
                                       PriorityQueue
 */

---> Tabela de calculos Big-O para as coleções do java:
(Com gráficos: https://www.bigocheatsheet.com/)

- List implementations:
                       get   add   contains  next remove(0)  iterator.remove
 ArrayList             O(1)  O(1)  O(n)      O(1) O(n)       O(n)
 LinkedList            O(n)  O(1)  O(n)      O(1) O(1)       O(1)
 CopyOnWrite-ArrayList O(1)  O(n)  O(n)      O(1) O(n)       O(n)
---------------------------------------------------------------------------
 - Set implementations:
                       add       contains  next      notes
 HashSet               O(1)      O(1)      O(h/n)    h is the table capacity
 LinkedHashSet         O(1)      O(1)      O(1)
 CopyOnWriteArraySet   O(n)      O(n)      O(1)
 EnumSet               O(1)      O(1)      O(1)
 TreeSet               O(log n)  O(log n)  O(log n)
 ConcurrentSkipListSet O(log n)  O(log n)  O(1)
---------------------------------------------------------------------------
 - Map implementations:
                       get       containsKey  next      Notes
 HashMap               O(1)      O(1)         O(h/n)    h is the table capacity
 LinkedHashMap         O(1)      O(1)         O(1)
 IdentityHashMap       O(1)      O(1)         O(h/n)    h is the table capacity
 EnumMap               O(1)      O(1)         O(1)
 TreeMap               O(log n)  O(log n)     O(log n)
 ConcurrentHashMap     O(1)      O(1)         O(h/n)    h is the table capacity
 ConcurrentSkipListMap O(log n)  O(log n)     O(1)
---------------------------------------------------------------------------
 - Queue implementations:
                       offer     peek  poll      size
 PriorityQueue         O(log n)  O(1)  O(log n)  O(1)
 ConcurrentLinkedQueue O(1)      O(1)  O(1)      O(n)
 ArrayBlockingQueue    O(1)      O(1)  O(1)      O(1)
 LinkedBlockingQueue   O(1)      O(1)  O(1)      O(1)
 PriorityBlockingQueue O(log n)  O(1)  O(log n)  O(1)
 DelayQueue            O(log n)  O(1)  O(log n)  O(1)
 LinkedList            O(1)      O(1)  O(1)      O(1)
 ArrayDeque            O(1)      O(1)  O(1)      O(1)
 LinkedBlockingDeque   O(1)      O(1)  O(1)      O(1)
 ---------------------------------------------------------------------------

---> Descrições sobre as complexidades:

As notações de complexidade Big-O são usadas para descrever o tempo de
execução ou espaço de memória necessários para um algoritmo à medida
que o tamanho da entrada aumenta. Essas notações são escritas usando
a notação O() e indicam a ordem de crescimento do algoritmo à medida
que o tamanho da entrada aumenta. Aqui estão as principais notações
de complexidade Big-O e seus significados:

    - O(1): Tempo de execução constante. Isso significa que o algoritmo
    leva a mesma quantidade de tempo, independentemente do tamanho da
    entrada.
    * Exemplo: acesso a um elemento em uma matriz.

    - O(log n): Tempo de execução logarítmico. Isso significa que o tempo
    de execução cresce proporcionalmente ao logaritmo do tamanho da entrada.
    * Exemplo: busca binária em uma lista ordenada.

    - O(n): Tempo de execução linear. Isso significa que o tempo de execução
    cresce proporcionalmente ao tamanho da entrada.
    * Exemplo: percorrer todos os elementos de uma lista.

    - O(n log n): Tempo de execução quase-linear. Isso significa que o tempo
    de execução cresce proporcionalmente ao tamanho da entrada multiplicado
    pelo logaritmo do tamanho da entrada.
    * Exemplo: algoritmos de classificação eficientes, como o mergesort ou o
    heapsort.

    - O(n^2): Tempo de execução quadrático. Isso significa que o tempo de
    execução cresce proporcionalmente ao quadrado do tamanho da entrada.
    * Exemplo: algoritmos de ordenação com desempenho inferior, como
    bubble sort ou selection sort.

    - O(2^n): Tempo de execução exponencial. Isso significa que o tempo de
    execução cresce exponencialmente em relação ao tamanho da entrada.
    * Exemplo: algoritmos de força bruta, como a resolução do problema do
    caixeiro-viajante.

    - O(n!): Tempo de execução fatorial. Isso significa que o tempo de execução
    cresce fatorialmente em relação ao tamanho da entrada.
    * Exemplo: resolução do problema de permutação.

    Geralmente, um algoritmo com complexidade Big-O menor é preferível, pois
    requer menos recursos computacionais à medida que o tamanho da entrada
    aumenta. No entanto, em muitos casos, é necessário comprometer entre a
    eficiência do algoritmo e a simplicidade de implementação ou outros
    requisitos do sistema.

-------------------------------------------------------------------------------

---> Classes/métodos aboradados neste package:

* Métodos equals() e hashCode(): Sempre garantir implementação linear delas.
    - Garantir que ambas estejam coerentes entre sí.
    - Essencial para se trabalhar com coleções.

* Interface List<E>: Interface mais básica no contexto de coleções, implementações:
    * Class ArrayList<E>: Classe mais básica que utiliza Array nativo em LowLevel.
    * Class LinkedList<E>: Não é para estar aqui na ordem de documentação pois é
    necessário estudos sobre os pontos destacados abaixo, porisso ela também
    está descrita abaixo, para não perder a ordem cronológica necessária para
    melhor entendimento.

* Util Class Collections: Classe 100% Utilitária, para trabalhar com Coleções.

* Operações importantes:
    - Sorting Lists: Organizando coleções em ordem ASC ou DESC. (Comparable/Comparator).
    - BinarySearch: Busca binária, utilizada em coleções ordenadas ASC ou DESC.

    - List to Array convertion: Convertendo List<E> em Array e vici versa.

* Interface Iterator<E>: Toda coleção até mesmo Array Nativo utiliza em LowLevel (for).
    - Interessante para realizar verificações antes de modificar uma coleção.
    - Evita `CurrentModificationException` por conta do ponto a cima.
    - Em casos de remove() utilizar programação funcional com removeIf().

* Class LinkedList<E>: Implementação de List não utiliza Array nativo em LowLevel.
    - Diferentemente de ArrayList que utiliza o Array nativo do java em Lowlevel,
    ela utiliza o conceito de "lista encadeada" e tem seu tamanho dinâmico sem
    precisar re-criar arrays e alterar o ponteiro da variável de referência.
    - Melhor implementação de List<E> para remoção de elementos. (Big-O).

* Interface Set<E>: Interface que serve para representar um conjunto de elementos
únicos e não ordenados.
    - Com métodos uteis para operações de conjuntos (união, interseçãoe e diferença).
    - Verificação de cardinalidade.
    - Mais performance em alguns casos.

    * Class HashSet<E>:
        - Implementação baseada em tabela hash;
        - Não mantém a ordem de inserção dos elementos;
        - É a mais rápida em termos de operações de adição, remoção e busca;
        - É adequada para casos em que a ordem dos elementos não importa e a
        velocidade é uma prioridade.

    * Class LinkedHashSet<E>:
        - Implementação baseada em tabela hash com lista duplamente ligada para
        manter a ordem de inserção;
        - Mantém a ordem de inserção dos elementos;
        - É um pouco mais lenta do que o HashSet, mas ainda é rápida;
        - É adequada para casos em que a ordem dos elementos importa
        e a velocidade é uma prioridade moderada.

    * TreeSet<E>:
        - Implementação baseada em árvore binária balanceada (Red-Black Tree);
        - Mantém os elementos em ordem crescente;
        - É mais lenta do que o HashSet e o LinkedHashSet, mas ainda é rápida;
        - É adequada para casos em que os elementos precisam ser mantidos em ordem crescente.

    * EnumSet<E>:
        - Implementação especializada para conjuntos de elementos enum;
        - Usa um vetor de bits para representar os elementos do conjunto;
        - É extremamente rápida e eficiente em termos de espaço;
        - É adequada para casos em que os elementos do conjunto são do tipo enum.

    * CopyOnWriteArraySet<E>:
        - Implementação baseada em um array que é copiado sempre que o conjunto é modificado;
        - Mantém os elementos em ordem de inserção;
        - É mais lenta do que as outras implementações do Set;
        - É adequada para casos em que a leitura do conjunto é muito mais frequente do que a modificação e a concorrência é um problema.

-------------------------------------------------------------------------------

---> Definições mais a fundo sobre cada um dos tópicos:

* equals() e hashCode():
- Utilizado para comparar Objetos, ambos devem ser concistentes entre sí.
- Equals e HashCode são muito utilzados em Listas complexas e com maior
  performance, como HashSet e HashMap. Pois ao invés de comparar elemento
  a elemento da lista, eles utilizam o hashCode como index, assim podemos
  acessar o Objeto da lista diretamente sem precisar realizar a iteração
  elemento a elemento como algoritmos mais simples fazem.

- Atenções sobre:
    CUIDADOS ao trabalhar com Objetos mutáveis e hashCode pois o hash muda,
    e assim pode gerar possíveis inconcistências ao utilizar métodos de
    busca e etc!
    - Sempre utilizar atributos constantes para gerar os hashs e garantir
    imutabilidade.

- Regras para a implementação do equals em um Object Model:

  - Reflexivo: x.equals(x) == true para tudo != null;
  - Simétrico: para x e y != null, se x.equals(y) == true logo y.equals(x)
  também tem que ser true.
  - Transitividade: para x, y e z != null,
  se x.equals(y) && x.equals(z) == true então y.equals(z) tambeḿ tem que
  ser true.
  - Consistente: para todas as chamadas, x.equals(x) sempre retorna true
  desde que x != null.
  para x != null, x.equals(null) tem que retorna false;

-------------------------------------------------------------------------------
* Interface List<E>:É uma das interfaces mais importantes do framework de
coleções do Java. Ela define um contrato para classes que representam
sequências ordenadas de elementos e oferece uma série de métodos para
manipulação dessas sequências, permitindo a adição, remoção e acesso
aos elementos por índice.
- Interface mais genérica utilizada neste contexto.
- Programação Orientada a Interface: As coleções no java são bem coesas
e essa abordagem é bastante utilizada pois ajuda na manutenção do cod.

---> Algumas implementações comuns da interface List incluem:

    * ArrayList: Implementa uma matriz dinâmica que cresce automaticamente à
    medida que novos elementos são adicionados a ela. O ArrayList é adequado
    para acesso aleatório aos elementos, mas não é tão eficiente para inserção
    ou remoção de elementos no meio da lista.

    * LinkedList: Implementa uma lista duplamente vinculada, que é mais eficiente
    do que o ArrayList para a inserção e remoção de elementos, mas menos eficiente
    para o acesso aleatório aos elementos.

    * Vector: É semelhante ao ArrayList, mas é sincronizada, o que significa que é
    segura para uso em ambientes multithread. No entanto, o Vector é menos eficiente
    do que o ArrayList.

    * Stack: É uma subclasse de Vector e implementa uma pilha (LIFO - último a entrar,
    primeiro a sair). A classe Stack fornece operações push e pop para inserção e
    remoção de elementos da pilha.

    * CopyOnWriteArrayList: É uma variante do ArrayList que é otimizada para acesso
    concorrente. Ela usa uma técnica de cópia na gravação para garantir que as
    operações de leitura sejam rápidas e seguras em ambientes multithread.

    * ImmutableList: É uma subclasse de List que fornece uma lista imutável, ou seja,
    uma lista cujos elementos não podem ser alterados após a criação. Ela é útil para
    garantir a integridade de dados em aplicativos que precisam compartilhar dados
    entre várias threads.

---> Diferenças de uso para cada classe que implementa:

    * ArrayList: Esta é uma das implementações mais comuns e mais usadas da interface
    List. Internamente usa um array nativo para armazenar os elementos, e pode ser
    redimensionada automaticamente quando necessário.
    Isso significa que o acesso aos elementos da lista é muito rápido, já que é
    possível acessar diretamente um elemento a partir de sua posição no array.
    No entanto, as operações de inserção e remoção podem ser caras, já que é
    necessário mover todos os elementos subsequentes no array para abrir espaço
    para um novo elemento. Por esta razão, a ArrayList é recomendada para aplicações
    que exigem acesso rápido aos elementos da lista, mas que não realizam muitas
    operações de inserção e remoção.

    * LinkedList: Ao contrário da ArrayList, a LinkedList usa uma lista duplamente
    encadeada para armazenar os elementos da lista.
    Isso torna as operações de inserção e remoção muito mais rápidas do que na
    ArrayList, pois não é necessário mover elementos no array. No entanto, o acesso
    aos elementos da lista pode ser mais lento, já que é necessário percorrer a lista
    a partir do início ou do fim para encontrar um elemento específico. Portanto, a
    LinkedList é recomendada para aplicações que realizam muitas operações de inserção
    e remoção, mas que não precisam de acesso rápido aos elementos da lista.

    * Vector: Esta é uma implementação sincronizada de ArrayList, o que significa que
    é segura para uso em ambientes concorrentes. No entanto, essa sincronização pode
    tornar a Vector menos eficiente do que a ArrayList em ambientes não concorrentes.
    Portanto, a Vector é recomendada para aplicações que exigem segurança em ambientes
    concorrentes. (Multi-threads)

    * Stack: Esta é uma implementação de pilha que é baseada em Vector. A Stack adiciona
    um método push para inserir elementos na pilha e um método pop para remover o elemento
    no topo da pilha. A Stack é uma estrutura de dados simples e pode ser usada para
    implementar algoritmos de processamento de dados que exigem uma pilha.

    * CopyOnWriteArrayList: esta é uma implementação que mantém uma cópia do array interno
    para cada operação de atualização.
    Isso significa que a lista é segura para uso em ambientes concorrentes sem a necessidade
    de sincronização externa. No entanto, essa cópia pode tornar a CopyOnWriteArrayList menos
    eficiente do que outras implementações para listas grandes ou com atualizações frequentes.
    Portanto, a CopyOnWriteArrayList é recomendada para aplicações que exigem segurança em
    ambientes concorrentes e que têm poucas atualizações na lista.

---> Pontos importantes e atenções em comum entre elas:

    1o - Eficiência: é importante escolher a implementação da List correta para as
    necessidades específicas da aplicação. Por exemplo, se a aplicação precisar realizar
    muitas operações de inserção e remoção, a LinkedList pode ser mais eficiente do que
    a ArrayList.

    2o - Sincronização: se a aplicação exigir acesso concorrente à lista, é importante
    escolher uma implementação que seja segura para uso em ambientes concorrentes, como
    a Vector ou a CopyOnWriteArrayList.

    3o - Uso de memória: algumas implementações da List, como a ArrayList, podem alocar
    mais memória do que o necessário para armazenar os elementos da lista. Portanto, é
    importante monitorar o uso de memória da aplicação e ajustar a implementação da List
    se necessário.

    4o - Métodos específicos: cada implementação da List pode oferecer métodos específicos
    que não estão disponíveis em outras implementações. É importante conhecer esses métodos
    e usá-los se eles atenderem às necessidades da aplicação.

    5o - Ordenação: algumas implementações da List oferecem suporte à ordenação de elementos,
    como a ArrayList e a LinkedList. É importante conhecer os algoritmos de ordenação
    disponíveis e escolher o mais apropriado para a aplicação.

    6o - Iteração: todas as implementações da List permitem a iteração sobre seus elementos
    usando um loop for-each ou um iterador. No entanto, a eficiência da iteração pode variar
    entre as implementações, dependendo da estrutura interna usada para armazenar os elementos.

    7o - Index: todas as implementações da List permitem acessar seus elementos por meio de um
    índice inteiro. No entanto, a eficiência do acesso ao elemento pode variar entre as
    implementações, dependendo da estrutura interna usada para armazenar os elementos.

    8o - Performance: a performance das operações de adição, remoção e busca pode variar
    significativamente entre as diferentes implementações da List. Por exemplo, a ArrayList
    é otimizada para acesso aleatório aos elementos, enquanto a LinkedList é otimizada para
    inserção e remoção em qualquer posição da lista.

    9o - Nulls: as implementações da List permitem que os elementos nulos sejam adicionados
     à lista, mas é importante estar ciente de que alguns métodos, como o método indexOf()
     da `ArrayList`, podem retornar resultados inesperados se houver elementos nulos na lista.

    10o - Clonagem: algumas implementações da List oferecem suporte à clonagem, que permite
    criar uma cópia da lista. No entanto, é importante estar ciente de que a clonagem pode
    criar uma referência compartilhada aos mesmos objetos armazenados na lista original.
    Ou seja, um link entre as "duas" listas, que no caso é apenas uma em LowLevel e
    na verdade seram duas variáveis de referência apontando para o mesmo array em baixo lvl.

    11o - Sublistas: algumas implementações da List permitem criar uma sublista que é uma
    visão parcial da lista original. No entanto, é importante estar ciente de que as operações
    na sublista podem afetar a lista original e vice-versa. Ou seja, cria link entre elas.

-------------------------------------------------------------------------------
* ArrayList<E>: É uma implementação da interface List que usa uma matriz
interna para armazenar seus elementos. Ao adicionar um elemento a uma
ArrayList, a matriz interna pode precisar ser redimensionada, o que
pode ser um processo lento se a lista for grande. Portanto, se você
precisa adicionar muitos elementos a uma ArrayList, considere usar um
LinkedList em vez disso.

- O método add() da ArrayList<T> adiciona um elemento ao final da lista.
Se você precisar adicionar um elemento em uma posição específica, use o
método add(int index, T element) em vez disso. No entanto, tenha cuidado
ao adicionar elementos em posições intermediárias, pois isso pode exigir
que todos os elementos subsequentes sejam movidos para cima na matriz
interna.

- A ArrayList<T> é uma estrutura de dados mutável, o que significa que os
elementos podem ser alterados a qualquer momento. Isso pode ser útil em
alguns casos, mas também pode tornar seu código mais difícil de entender
e depurar. Considere usar coleções imutáveis, como a List<T> fornecida
pela classe Collections, sempre que possível.

- A ArrayList<T> não é sincronizada, o que significa que não é segura para
uso em threads concorrentes. Se você precisar compartilhar uma lista entre
várias threads, considere usar uma lista sincronizada ou um
CopyOnWriteArrayList<T> em vez disso.

- A ArrayList<T> implementa a interface Serializable, o que significa que
pode ser serializada e desserializada facilmente. Isso pode ser útil ao
salvar e carregar listas em um arquivo ou enviar listas pela rede.

-------------------------------------------------------------------------------
* SortingLists:
- Ordenando listas com o método Collections.sort(): método sobrecarregado,
podemos passar apenas a coleção que será ordenada, ou também acrescentar
um obj que implemente Comparator<T> no segundo parâmetro.

- Para ordenar a coleção, o obj em ordenação desta lista precisa implementar
Comparable<T> ou então será necessário criar uma instância Comparator<T> e
nele definir a regra de ordenação para o método compare().
(Oque torna um obj maior>, menor< ou igual== a outro?).
    - Obs: Mesma regra definida em um obj que implements Comparable<T>.

- Quando utilizar Comparable<T> ou Comparator<T> ?
    Implementamos o Comparable<T> num objeto quando queremos definir uma
    regra "Geral/Natural" de ordenação, essa seria a regra "default" de
    ordenação, ou seja, válida para o programa como um "tôdo" pois toda
    vez que o Java precisar comparar dois objetos, ele utilizará essa
    regra como critério, "chamando" o método compareTo(Object otherObj);

    - Implementamos o Compartor<T> quando queremos alterar por algum
    motivo essa regra inicial apenas em pontos específicos no programa,
    alterando assim essa ordenação "Natural/Default" do Objeto em
    questão.
        - Também podemos utilizar essa abordagem quando o objeto em
        ordenação não estiver sob nosso controle, por algum motivo
        como API's de terceiros ou classes que não conhecemos bem
        o seu comportamento/uso geral no programa, então para isso
        criamos ou implementamos um Comparator<T> e definimos a
        regra, sem afetar a Classe do Objeto em ordenação em sí.

    - Dica: Caso queira utilizar como critério de comparação Objetos
    internos a outros em aninhamento como por exemplo ordenar uma
    lista de pedidos com base no nome dos clientes, ou ir além, basta
    na implementação do Comparator<T> utilizar o get multiplas vezes
    até encontrar o Objeto do nível correto:

      @Override
      public int compare(Pedido p1, Pedido p2) {
          String nomeCliente1 = p1.getCliente().getNome(); // -> Aqui poderia ter get().get().get()...
          String nomeCliente2 = p2.getCliente().getNome(); // Até chegar no nível do Objeto desejado.
          return nomeCliente1.compareTo(nomeCliente2);
      }

- Além dessa implementação necessária para a ordenação de elementos,
também é necessário a implementação correta do equals() e hashCode().

- Collections: Classe 100% estática utilizada como Utilitário no contexto
de coleções no Java.

-------------------------------------------------------------------------------
* BinarySearch: Método utilitário do Collections.
- É um dos métodos estáticos do Collections.binarySearch(numbersList, 6);
Aonde ´numberList´ é a coleção e ´6´ é o index do elemento em search.
- Podemos também aplicar esse método em Arrays nativos do Java,
  porém o mesmo deve garantir a ordenação dos elementos.
- Para utilizar é necessário passar uma coleção ordenada (sort()),
pois ele utiliza tecnicas de programação que otimizam a performance.

- REGRA: O retorno será o index do elemento, com algumas convenções sendo
 elas:
    - A Diferença dele para um indexOf() é que além de retornar NEGATIVO
    quando um Objeto não existe na lista retorna também em qual posição
    o elemento deveria estar para manter a lista ordenada.

    - Quando EXISTE o elemento em busca, retorna um inteiro POSITIVO que
    representa o index dele.

    - Quando NÃO existe o elemento em busca, retorna um inteiro NEGATIVO
    que representa o index em que o elemento deve ser inserido para manter
    a lista ordenada subtraindo 1. (-(ponto de inserção) -1)
    Aonde "ponto de inserção" == index aonde o elemento deveria estar para
    manter a lista ordenada.
        - Subtraí 1 pois se o valor retornado fosse 0 não saberiamos se é
        o resultado Exists do elemento, ou se é a posição em que o elemento
        deveria estar, ou seja NotExists.
            - OU SEJA, ele garante que só irá retornar POSITIVO se o elemento
            Exists, caso contrario o retorno será sempre NEGATIVO.

            - PORISSO deve se ATENTAR ao criar coleções com valores NEGATIVOS,
            pois ai iria adicionar mais complexidade nesta lógica,
            e a matematica que deverá ser aplicada após o processamento,
            fazendo assim com que a transformação correta do elemento teria
            que levar em consideração esse fator.

        - FÓRMULA em casos de retorno NEGATIVO indicando que o elemento não
        exists na lista, sendo necessário assim transformar o index
        corretamente para obter o index real no qual o elemento deveria estar
        para manter a lista organizada/sorted:

              int realIndex = 0;
              if (indexOfElementWithBinarySearched < 0){
                  realIndex = -(indexOfElementWithBinarySearched + 1);

                  ... Aqui podemos realizar a criação e inserção do Objeto na lista,
                  de uma forma em que mantém a lista organizada na regra definida em Comparable<T>

              } else { // POSITIVO não é preciso, pois o index vem corretamente.
                  realIndex = indexOfElementWithBinarySearched;
              }

- Vantagens de se utilizar a busca binária: APENAS e só APENAS se aplica em
listas Sorted/Ordenadas!!

     - A vantagem de utilizar o método binarySearch() é a eficiência em
     encontrar um elemento de uma lista ordenada. A busca binária é um
     algoritmo eficiente para encontrar um elemento de uma lista ordenada,
     pois a busca é feita pela metade da lista em cada iteração, reduzindo
     drasticamente o número de comparações necessárias.

     - Em comparação com uma busca linear, em que cada elemento da lista é
     verificado um por um até que o elemento procurado seja encontrado, a
     busca binária é significativamente mais rápida para listas maiores.
     Isso se deve ao fato de que a BUSCA BINÁRIA corta a lista pela METADE
     a cada iteração, enquanto a busca LINEAR percorre TODOS os elementos
     da lista.

- Desvantagens de se utilizar a busca binária:

    - A lista deve estar ordenada: A busca binária requer que a lista esteja
    ordenada em ordem crescente ou decrescente antes de executar a busca.
    Isso significa que, se a lista não estiver ordenada corretamente, será
    necessário ordená-la antes de realizar a busca, o que pode ser um
    processo custoso em termos de tempo.

    - Não é adequado para listas pequenas: A busca binária é mais eficiente
    para listas grandes, pois seu desempenho aumenta exponencialmente à
    medida que o tamanho da lista aumenta. Para listas pequenas, o desempenho
    da busca binária pode ser comparável ou até mesmo pior do que outras
    técnicas de busca, como a busca linear.

    - Não é adequado para listas mutáveis: A busca binária é projetada para
    ser usada com listas imutáveis, ou seja, listas que não mudam durante a
    busca. Se a lista estiver sendo modificada enquanto a busca estiver em
    andamento, pode haver problemas com a ordem dos elementos e o resultado
    da busca pode ser impreciso.

    - Não é adequado para tipos de dados complexos: A busca binária é melhor
    usada com tipos de dados simples, como inteiros ou caracteres. Para tipos
    de dados complexos, como objetos personalizados, pode ser necessário
    definir uma ordem de classificação personalizada ou sobrescrever o método
    compareTo() para que a busca binária funcione corretamente.

    - Requer que a lista implemente a interface List: O método binarySearch()
    do Collections só pode ser usado em listas que implementam a interface
    List. Se você estiver usando uma lista que não implementa a interface
    List, será necessário usar uma implementação personalizada da busca binária.

    - Pode retornar resultados imprecisos ou inesperados: Em alguns casos, o
    método binarySearch() pode retornar resultados imprecisos ou inesperados,
    especialmente se a lista contiver elementos duplicados. Nesses casos, o
    método pode retornar qualquer índice correspondente a um elemento
    encontrado, mas não necessariamente o índice do elemento desejado.

    - Não é adequado para buscas por critérios complexos: A busca binária é
    adequada para encontrar elementos por valor exato. No entanto, se você
    precisar procurar por elementos com base em critérios mais complexos,
    como faixa de valores ou correspondência parcial de strings, a busca
    binária pode não ser a melhor opção.

    - A complexidade da implementação: Implementar a busca binária requer
    conhecimento prévio e pode ser um processo complexo, especialmente se
    você estiver lidando com casos não triviais, como a busca em listas
    multidimensionais.

    - Pode ser menos eficiente em cenários de memória limitada: A busca
    binária requer que a lista esteja ordenada em memória antes de executar
    a busca, o que pode ser um problema em cenários com limitações de memória.
    Em tais cenários, outras técnicas de busca, como a busca linear ou a busca
    hash, podem ser mais eficientes.

-------------------------------------------------------------------------------
* List to Array Convertion: Conversões Array nativo <=> List e vici versa.

- Transformando uma List<E> em um Array:
    Object[] objects = inteiros.toArray(); -> sem especificar ele retorna Objects
    Integer[] listToArray = integersList.toArray(new Integer[0]);

- Transformando um Array em uma List<E>:
    List<Integer> integers = Arrays.asList(listToArray); // linka os dois arrays em uma List<T>
    //integers.add(4); -> Operação inválida pois Arrays não podem ser redimensionados.
    integers.set(2, 4); // Operação VÀLIDA pois não estemos alterando o dimensionamento do array (size)

    List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray)); // SOLUÇÃO: quebra o link

- Arrays.asList():
    - É otimizado para criar uma lista de tamanho fixo a partir de um array
     existente e, portanto, é mais eficiente em termos de memória e
     desempenho. Além disso, o método retorna uma visualização da lista,
     o que significa que não é criada uma nova instância de lista. Em vez
     disso, é criado um objeto interno que atua como uma "janela" para o
     array subjacente, permitindo que você trabalhe com a lista como se
     fosse uma lista regular.

         - SOLUÇÃO: Para quebrar esse vínculo utilizar o array no construtor
         e criar uma nova instância de List<T>:
         List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray));

-------------------------------------------------------------------------------
* Iterator: Classe utilizada para percorrer listas, neste contexto ela é util
em casos aonde é preciso realizar alguma verificação antes de tomar alguma
ação sobre cada elemento da lista, por exemplo quando se quer remover um
elemento de uma forma segura (safe delete) evitando assim Exceptions como a
´CurrentModificationException´, pois não é recomendável realizar mudanças
correntes em coleções que estão sendo percorridas (looping).

- Com Iterator que checa antes de executar uma ação (SEM programação funcional):

        Iterator<PatientModel> patientIterator = patientModelList.iterator();
        while (patientIterator.hasNext()) {
            PatientModel patient = patientIterator.next();
            if(patient.getPriority() == 0){
                patientIterator.remove();
            }
        }

- Alternativa recomendável SEM Iterator, utilizando programação funcional:

    patientModelList.removeIf(patient -> patient.getPriority() == 0);

- Em Java, um Iterator é uma interface que permite percorrer coleções de elementos,
como List, Set e Map. Ele fornece um conjunto de métodos para acessar e percorrer
os elementos de uma coleção, sem expor a estrutura interna da coleção.

  - A interface Iterator define três métodos principais:

      hasNext(): retorna true se a coleção contém mais elementos a serem iterados.
      next(): retorna o próximo elemento na coleção.
      remove(): remove o elemento atual da coleção.

- O Iterator é útil em situações em que você precisa percorrer uma coleção de
elementos, mas não sabe quantos elementos ela contém ou não quer expor a
estrutura interna da coleção. Por exemplo, se você estiver trabalhando com uma
List grande e quiser iterar apenas sobre alguns elementos específicos, pode
usar um Iterator em vez de percorrer a lista inteira.

- Outra utilidade do Iterator é permitir a remoção segura de elementos de uma
coleção enquanto a iteração está em andamento. Ao usar o método remove() do
Iterator, você pode remover o elemento atual da coleção sem causar problemas
de concorrência ou exceções do tipo ´ConcurrentModificationException´.

---> Pontos a se considerar quando se utiliza:

    1o - Use o for-each loop sempre que possível: o for-each loop é uma forma
    mais simples e segura de iterar sobre uma coleção em Java. Ele utiliza um
    Iterator por baixo dos panos e garante que a iteração será feita
    corretamente, sem precisar se preocupar com os detalhes do Iterator
    manualmente.

    2o - Use o try-with-resources para garantir a liberação dos recursos: quando
    se trabalha com um Iterator, é importante garantir que ele seja liberado
    corretamente após o uso para evitar possíveis vazamentos de recursos.
    O try-with-resources é uma forma conveniente de garantir que o Iterator seja
    fechado automaticamente ao final do bloco de código.

    3o - Prefira usar o `ListIterator` para iterações bidirecionais: se você
    precisar iterar sobre uma lista em ambas as direções (para frente e para
    trás), é recomendável usar o `ListIterator` em vez do `Iterator.
    O `ListIterator` suporta iterações bidirecionais e oferece mais recursos,
    como a possibilidade de adicionar ou remover elementos durante a iteração.

    4o - Use o `Spliterator` para iterações em paralelo: se você precisar iterar
    sobre uma coleção em paralelo (em várias threads), é recomendável usar o
    Spliterator. O Spliterator é projetado para suportar iterações em paralelo
    de forma segura e eficiente, sem precisar se preocupar com problemas de
    concorrência.

    5o - Use o método forEachRemaining() para iterações restantes: o método
    forEachRemaining() é um método do Iterator que itera sobre os elementos
    restantes na coleção e executa uma ação especificada. Ele é útil quando
    você precisa executar uma ação em todos os elementos da coleção, mesmo
    que a iteração tenha sido interrompida prematuramente. Por exemplo, você
    pode usar o forEachRemaining() para limpar uma coleção depois que ela foi
    parcialmente iterada.

    6o - Considere usar a classe Iterable para criar suas próprias coleções
    iteráveis: se você estiver criando suas próprias coleções personalizadas,
    é recomendável implementar a interface Iterable para permitir que elas
    sejam iteradas facilmente usando um for-each loop ou um Iterator.
    A interface Iterable exige a implementação do método iterator(), que deve
    retornar um objeto Iterator para a coleção.
        - Para listas personalizadas que seram utilizadas paralelamente,
        deve-se implementar a interface Spliterator.

    7o - Use o Enumeration para iteração em coleções legadas: se você estiver
    trabalhando com coleções legadas (anteriores ao Java 2) que não implementam
    a interface Iterable, pode usar a classe Enumeration para iterar sobre os
    elementos. A classe Enumeration oferece métodos semelhantes aos do Iterator,
    mas é menos flexível e menos eficiente.

    8o - Considere usar bibliotecas de iteração externas: se você estiver
    trabalhando com coleções complexas ou precisar de funcionalidades avançadas
    de iteração, pode ser útil usar bibliotecas de iteração externas, como o
    Apache Commons Collections ou o Guava. Essas bibliotecas oferecem recursos
    avançados de iteração, como iteração baseada em predicado, iteração reversa,
    iteração filtrada e muito mais.

    9o - Use o StreamSupport para criar um Stream a partir de um Iterator ou
    Spliterator: se você tiver um objeto Iterator ou Spliterator e desejar
    convertê-lo em um Stream, pode usar o método StreamSupport.stream() do
    Java 8. Esse método permite que você crie um Stream a partir de um
    Iterator ou Spliterator personalizado.

    10o - Use o Optional para evitar exceções de iteração: em algumas situações,
    pode ser possível que a coleção esteja vazia ou que não haja mais elementos
    para iterar. Nesses casos, em vez de lançar uma exceção, é recomendável usar
    a classe Optional para lidar com o valor nulo. O método next() do Iterator
    retorna um objeto Optional, permitindo que você verifique se há um próximo
    elemento sem lançar uma exceção.

    11o - Use o método hasNext() com moderação: embora o método hasNext() do
    Iterator seja útil para verificar se há mais elementos na coleção, seu uso
    excessivo pode afetar negativamente o desempenho. Isso ocorre porque o método
    hasNext() geralmente precisa percorrer a coleção para verificar se há mais
    elementos. Em vez de verificar a cada iteração, é recomendável verificar
    apenas quando necessário ou usar o for-each loop para iterar sobre a coleção.

-------------------------------------------------------------------------------
* LinkedList<E>: Listas encadeadas/ligadas
- Melhor Implementação de List para remoção de elementos:
    Complexidade Big-O remove(): O(1);

LinkedList é uma estrutura de dados em Java que é usada para armazenar uma
coleção de elementos, onde cada elemento é chamado de nó e contém um valor
e um ponteiro para o próximo nó na lista. (Estilo "Trem" aonde cada vagão é
um Nó que aponta para o anterior e próximo).

Essa estrutura de dados é útil quando precisamos inserir ou excluir elementos
com frequência, pois ela permite que as operações de inserção e remoção sejam
realizadas com eficiência, sem a necessidade de realocar memória como ocorre
em um array.

Além disso, a LinkedList é uma lista duplamente encadeada, o que significa que
cada nó também possui um ponteiro para o nó anterior na lista, permitindo
percorrer a lista em ambas as direções.

Na prática, as LinkedLists são usadas em diversas aplicações, como em
implementações de filas, pilhas, e listas de reprodução de músicas,
onde é necessário adicionar ou remover elementos com frequência.

- Vantagens:

    - Inserção e remoção eficientes: Uma das principais vantagens das LinkedLists
    é que a inserção e a remoção de elementos podem ser muito eficientes, pois não
    requerem deslocamento de outros elementos como ocorre em arrays.

    - Flexibilidade de tamanho: LinkedLists permitem adicionar ou remover elementos
    dinamicamente, o que significa que você não precisa alocar um tamanho fixo de
    memória, como acontece em arrays.
    Isso pode ser útil quando você não sabe de antemão quantos elementos precisa
    armazenar.

    - Iteração eficiente: Iterar sobre todos os elementos de uma LinkedList pode
    ser muito eficiente, já que cada elemento contém um ponteiro para o próximo
    elemento, o que permite percorrer toda a lista sem a necessidade de cálculo
    de índices.

- Desvantagens:

    - Acesso aleatório ineficiente: Enquanto as LinkedLists são boas para inserir
    e remover elementos, o acesso aleatório a um elemento específico pode ser
    ineficiente, pois não há um índice fixo para cada elemento, exigindo uma
    busca sequencial.

    - Consumo de memória: Cada elemento de uma LinkedList requer uma alocação de
    memória separada, o que pode tornar as LinkedLists menos eficientes em termos
    de memória do que arrays, especialmente para listas de tamanho grande.

    - Dificuldades em ordenação: É mais difícil ordenar elementos em uma LinkedList
    do que em um array, uma vez que os elementos estão distribuídos de forma não
    contígua na memória.
    Isso pode levar a algoritmos de classificação menos eficientes em uma LinkedList.

    - Dificuldade de inversão: Inverter uma LinkedList é uma operação relativamente
    complexa, uma vez que envolve a atualização de ponteiros para cada elemento.
    Isso pode tornar a inversão menos eficiente do que em outras estruturas de dados.

Em geral, as LinkedLists são úteis quando a eficiência de inserção e remoção é uma
prioridade e quando o tamanho da lista pode mudar ao longo do tempo. Por outro lado,
se você precisa de acesso aleatório eficiente a elementos ou se está trabalhando com
listas muito grandes, pode ser melhor escolher uma estrutura de dados diferente, como
um array ou uma árvore.

---> Pontos a se considerar quando se utiliza:

    1o - Inserção e remoção de elementos: como mencionado anteriormente, a
    LinkedList é uma estrutura de dados que permite a inserção e remoção
    eficiente de elementos. Porém, tenha cuidado ao realizar essas
    operações em listas grande, pois elas podem ser computacionalmente
    custosas.

    2o - Acesso aos elementos: a LinkedList não é uma estrutura de dados
    adequada para acesso aleatório aos elementos, ou seja, acessar um
    elemento pelo seu índice.
    Isso porque para acessar um elemento específico, é necessário percorrer
    a lista a partir do início ou do fim, o que pode ser lento em listas
    grandes.

    3o - Uso de iterações: o uso de iterações (loops) em LinkedLists é comum
    para percorrer todos os elementos ou realizar alguma operação em cada
    elemento. No entanto, tenha cuidado ao modificar a lista durante a
    iteração, pois isso pode causar comportamentos inesperados ou mesmo erros.

    4o - Uso do Iterator: para percorrer uma LinkedList de forma segura, é
    recomendado utilizar a classe Iterator do Java, que permite iterar sobre
    os elementos da lista sem causar modificações inesperadas.

    5o - Uso do método equals: a LinkedList implementa o método equals para
    comparar duas listas. No entanto, esse método compara os elementos da
    lista um a um, o que pode ser lento em listas grandes. Portanto, tenha
    cuidado ao usar o método equals em LinkedLists grandes.

    6o - Uso do método clone: a LinkedList também implementa o método clone
    para criar uma cópia da lista. No entanto, essa operação pode ser custosa
    em termos de memória e processamento, especialmente em listas grandes.
    Portanto, tenha cuidado ao usar o método clone em LinkedLists grandes.

    7o - Uso do método toArray: o método toArray da LinkedList permite criar
    um array com os elementos da lista. No entanto, esse método cria uma cópia
    dos elementos da lista, o que pode ser lento em listas grandes. Portanto,
    tenha cuidado ao usar o método toArray em LinkedLists grandes.

    8o - Uso de memória: a LinkedList consome mais memória do que outras
    estruturas de dados, como arrays, devido à necessidade de armazenar
    referências para cada elemento da lista. Portanto, é importante
    considerar a quantidade de memória disponível e o tamanho da
    lista ao escolher a implementação adequada.

    9o - Comportamento de ordenação: a LinkedList não é automaticamente
    ordenada em Java, portanto, se você precisa de uma lista ordenada,
    é necessário implementar a ordenação por conta própria.

-------------------------------------------------------------------------------
Fonte interessanta: https://www.devmedia.com.br/diferencas-entre-treeset-hashset-e-linkedhashset-em-java/29077
* Interface Set<E>: Set é uma interface com o mesmo contexto da List, porém para
trabalhar com HashSet, LinkedHashSet, NavigableSet e TreeSet.

A interface Set é uma das interfaces de coleções do Java e serve para representar
um conjunto de elementos únicos e não ordenados. Os elementos de um Set não são
duplicados e não possuem uma ordem específica.

A interface Set define um conjunto de métodos que permitem a adição, remoção e
verificação de elementos em um conjunto, bem como a verificação de sua
cardinalidade e a realização de operações de conjuntos, como união, interseção
e diferença. Alguns dos principais métodos da interface Set incluem:

    - add(elemento): adiciona um elemento ao conjunto, caso ele ainda não esteja presente;
    - remove(elemento): remove um elemento do conjunto, caso ele esteja presente;
    - contains(elemento): verifica se um elemento está presente no conjunto;
    - size(): retorna o número de elementos do conjunto;
    - isEmpty(): verifica se o conjunto está vazio;
    - clear(): remove todos os elementos do conjunto;
    - iterator(): retorna um objeto Iterator para percorrer os elementos do conjunto.

A interface Set é implementada por diversas classes no Java, incluindo HashSet,
TreeSet e LinkedHashSet. Cada uma dessas classes implementa a interface Set de
forma diferente, com características específicas que podem ser mais adequadas
para diferentes cenários de uso.

Alguns exemplos de uso da interface Set incluem a remoção de elementos duplicados
de uma lista, a verificação de elementos únicos em um conjunto de dados e a
realização de operações de conjuntos, como a interseção de dois conjuntos.
A interface Set é uma ferramenta importante na programação em Java para lidar com
conjuntos de elementos de forma eficiente e elegante.

É importante lembrar que, como um Set não permite elementos duplicados, a classe
dos elementos deve implementar os métodos equals() e hashCode() corretamente para
garantir que os elementos sejam comparados corretamente.

---> Algumas implementações comuns da interface Set no Java incluem:

    * HashSet: implementação baseada em tabela hash que fornece acesso rápido aos
    elementos, mas não mantém a ordem dos elementos.

    * TreeSet: implementação baseada em árvore que mantém os elementos em ordem
    crescente ou decrescente, mas pode ser mais lenta que o HashSet.

    * LinkedHashSet: implementação que mantém a ordem de inserção dos elementos,
    mas pode ser mais lenta que o HashSet.

- Vantagens:

    - Não permitem elementos duplicados, o que pode ajudar a evitar erros em
    operações com conjuntos de dados.

    - Permitem operações de união, interseção e diferença entre conjuntos,
    facilitando a manipulação de dados.

    - Fornecem uma variedade de implementações diferentes que podem ser escolhidas
    com base nas necessidades específicas do problema em questão.

    - Oferecem desempenho rápido para operações de adição, remoção e verificação de
    pertinência de elementos em relação a outras estruturas de dados.

- Desvantagens:

    - Não permitem acesso a elementos com base em sua posição no conjunto, já que
    não mantêm uma ordem específica.

    - Algumas implementações podem ser menos eficientes do que outras para
    determinadas operações, o que pode levar a um desempenho abaixo do esperado.

    - O uso excessivo de conjuntos pode levar a um aumento no uso de memória,
    especialmente se eles contiverem muitos elementos.

    - As classes que implementam a interface Set são mutáveis, o que significa
    que elas podem ser modificadas a qualquer momento, tornando difícil prever
    seu estado atual.

---> Diferenças de uso para cada classe que implementa:

* HashSet:
    - Implementação baseada em tabela hash;
    - Não mantém a ordem de inserção dos elementos;
    - É a mais rápida em termos de operações de adição, remoção e busca de elementos;
    - É adequada para casos em que a ordem dos elementos não importa e a velocidade é uma prioridade.

* LinkedHashSet:
    - Implementação baseada em tabela hash com lista duplamente ligada para manter a ordem de inserção;
    - Mantém a ordem de inserção dos elementos;
    - É um pouco mais lenta do que o HashSet, mas ainda é rápida;
    - É adequada para casos em que a ordem dos elementos importa e a velocidade é uma prioridade moderada.

* TreeSet:
    - Implementação baseada em árvore binária balanceada (Red-Black Tree);
    - Mantém os elementos em ordem crescente;
    - É mais lenta do que o HashSet e o LinkedHashSet, mas ainda é rápida;
    - É adequada para casos em que os elementos precisam ser mantidos em ordem crescente.

* EnumSet:
    - Implementação especializada para conjuntos de elementos enum;
    - Usa um vetor de bits para representar os elementos do conjunto;
    - É extremamente rápida e eficiente em termos de espaço;
    - É adequada para casos em que os elementos do conjunto são do tipo enum.

* CopyOnWriteArraySet:
    - Implementação baseada em um array que é copiado sempre que o conjunto é modificado;
    - Mantém os elementos em ordem de inserção;
    - É mais lenta do que as outras implementações do Set;
    - É adequada para casos em que a leitura do conjunto é muito mais frequente do que a modificação e a concorrência é um problema.

---> Pontos importantes e atenções em comum entre elas:

    1o - Evite a adição de elementos duplicados: como as classes que implementam
    a interface Set não permitem elementos duplicados, é importante garantir que
    os elementos adicionados sejam únicos. Para isso, é possível sobrescrever o
    método equals() do objeto que será adicionado ou implementar a interface
    Comparable para definir uma ordem natural para os elementos.

    2o - Escolha a implementação correta: o Java oferece várias implementações
    diferentes da interface Set, cada uma com suas próprias características e
    desempenho. Por exemplo, a classe HashSet é eficiente para operações de
    adição e busca, mas não mantém uma ordem específica para os elementos.
    Já a classe TreeSet mantém os elementos em ordem natural ou definida por um
    Comparator, mas tem um desempenho um pouco mais lento. É importante escolher
    a implementação correta com base nas necessidades do seu código.

    3o - Fique atento à complexidade de tempo: algumas operações em conjuntos
    podem ter complexidade de tempo alta, especialmente em conjuntos grandes.
    Por exemplo, a operação de união entre dois conjuntos grandes pode ser
    bastante demorada, mesmo em uma implementação eficiente. Portanto, é
    importante estar ciente dessas limitações e considerar alternativas caso
    seja necessário trabalhar com conjuntos muito grandes.

    4o - Use métodos específicos: as classes que implementam a interface Set
    fornecem uma variedade de métodos específicos que podem facilitar a
    manipulação de conjuntos de dados. Por exemplo, o método addAll() permite
    adicionar todos os elementos de uma coleção em um conjunto existente,
    enquanto o método retainAll() permite manter apenas os elementos em comum
    entre dois conjuntos. É importante explorar esses métodos para obter o
    máximo de desempenho e facilidade de uso.

    7o - Considere a sincronização: as classes que implementam a interface Set
    não são thread-safe por padrão, o que significa que não é seguro acessá-las
    de várias threads simultaneamente. Se você precisar trabalhar com conjuntos
    em um ambiente concorrente, é importante sincronizar o acesso ao conjunto
    com as palavras-chave synchronized ou com as classes da biblioteca
    java.util.concurrent.

    8o - Não altere o conjunto enquanto estiver percorrendo seus elementos: se
    você estiver percorrendo um conjunto usando um iterador, é importante não
    alterar o conjunto enquanto estiver percorrendo seus elementos.
    Isso pode levar a resultados inesperados ou erros de tempo de execução.
    Em vez disso, use o iterador para percorrer o conjunto e, em seguida,
    modifique-o após concluir a iteração.

    9o - Garanta a imutabilidade do conjunto quando necessário: em alguns casos,
    pode ser desejável que um conjunto seja imutável, ou seja, que seus elementos
    não possam ser adicionados, removidos ou alterados após sua criação. Para isso,
    o Java oferece a classe Collections.unmodifiableSet(), que cria uma visão
    imutável de um conjunto existente. É importante lembrar que a visão é apenas
    de leitura e qualquer tentativa de alteração do conjunto lançará uma exceção.

    10o - Considere a ordem dos elementos: algumas implementações da interface Set,
    como a TreeSet e a LinkedHashSet, mantêm uma ordem específica para os elementos.
    É importante considerar essa ordem ao escrever código que utiliza essas
    implementações. Por exemplo, se você precisar percorrer os elementos de um
    TreeSet em ordem crescente, pode usar o método iterator() ou o método forEach()
    com um Comparator apropriado.

    11o - Tenha cuidado ao usar objetos mutáveis como elementos: se você usar
    objetos mutáveis como elementos de um conjunto, é importante ter cuidado
    ao modificá-los. Se um objeto for modificado de uma maneira que altere sua
    posição no conjunto, pode ocorrer um comportamento inesperado. Por exemplo,
    se você usar uma lista como elemento de um conjunto e remover um elemento
    da lista, o conjunto poderá ficar em um estado inconsistente.

    12o - Esteja ciente das diferenças entre equals() e hashCode(): para que uma
    classe possa ser usada como elemento de um conjunto, ela deve sobrescrever os
    métodos equals() e hashCode(). É importante lembrar que esses métodos têm
    comportamentos diferentes: equals() é usado para testar a igualdade entre
    objetos, enquanto hashCode() é usado para calcular a posição do objeto no
    conjunto. Portanto, é importante garantir que esses métodos sejam consistentes
    entre si para evitar resultados inesperados.

-------------------------------------------------------------------------------
* Class HashSet: A classe é uma implementação da interface Set que utiliza uma tabela
hash para armazenar seus elementos. Ela não mantém uma ordem específica dos
elementos e não permite a inclusão de elementos duplicados (DISTINCT).

- Não é indexada, ou seja não é possível utilizar index para obter elementos,
então para operações deste tipo será necessário percorrer a coleção.

- Não mantém a ordem de inserção dos elementos, a coleção se ajustará de acordo
com o hashCode final gerado, porisso não é possível garantir a ordem dos
elementos. (LinkedHashSet vem para resolver isso, mantendo a ordem de inserção).

- Algumas das principais aplicações e utilidades da classe HashSet incluem:

    - Remoção de elementos duplicados: ao adicionar todos os elementos de uma
    coleção a um HashSet, os elementos duplicados serão automaticamente
    removidos, deixando apenas os elementos únicos.

    - Verificação de pertencimento: o método contains() pode ser usado para
    verificar se um determinado elemento está presente no HashSet.

    - Armazenamento de objetos complexos: o HashSet pode armazenar objetos
    complexos, como instâncias de classes personalizadas, desde que a classe
    desses objetos implemente corretamente os métodos equals() e hashCode().

    - Agilidade na recuperação de elementos: a implementação do HashSet
    utilizando tabela hash fornece acesso rápido aos elementos, com tempo
    constante em média para operações como add(), remove() e contains().

    - Cálculo de interseção, união e diferença de conjuntos: o HashSet possui
    métodos que permitem realizar operações de conjunto, como união, interseção
    e diferença.

    - Não é sincronizada: a classe HashSet não é thread-safe, o que significa
    que não é recomendado utilizá-la em ambientes concorrentes sem a devida
    sincronização.

    - Não aceita elementos duplicados: o HashSet não permite que elementos
    duplicados sejam adicionados à coleção, o que pode ser útil em muitos casos.

    - A ordem de iteração não é previsível: como o HashSet não mantém uma ordem
    específica dos elementos, a ordem em que os elementos são iterados pode variar
    de acordo com a implementação.

    - Aceita elementos nulos: o HashSet aceita elementos nulos, mas é importante
    lembrar que a comparação de elementos nulos é diferente da comparação de outros
    elementos.

    - Pode consumir muita memória: como o HashSet é baseado em tabela hash, ele pode
    consumir uma quantidade significativa de memória em relação a outras estruturas
    de dados, principalmente quando o fator de carga da tabela é alto.

    - Pode ser utilizado como base para outras implementações: a classe HashSet pode
    ser utilizada como base para outras implementações de conjuntos, como LinkedHashSet,
    que mantém a ordem de inserção dos elementos, e EnumSet, que é uma implementação
    especializada para conjuntos de enumerações.

É importante lembrar que a classe dos objetos armazenados no HashSet deve
implementar corretamente os métodos equals() e hashCode() para garantir a
correta comparação dos elementos e o funcionamento correto da tabela hash.
Além disso, por não manter uma ordem específica dos elementos, a iteração
sobre um HashSet pode ocorrer em qualquer ordem.

- Vantagens:

    - Eficiência: a classe HashSet é muito eficiente em termos de tempo de
    busca e inserção de elementos.
    Isso é devido à sua implementação baseada em hash tables, o que permite
    um acesso rápido aos elementos.

    - Garante elementos únicos: a classe HashSet garante que não haverá
    elementos duplicados na coleção, o que pode ser muito útil em algumas
    situações.

    - Interface simples: a interface da classe HashSet é simples e fácil de usar,
    permitindo que os desenvolvedores possam trabalhar com ela facilmente.

    - Eficiência na realização de operações de adição, remoção e verificação de
    pertencimento em relação a outros tipos de conjuntos, especialmente quando
    a quantidade de elementos é grande.

    - A capacidade de armazenar elementos sem ordem definida, o que pode ser útil
    em alguns casos.

- Desvantagens:

    - Não mantém ordem: a classe HashSet não mantém a ordem dos elementos
    inseridos na coleção. Se a ordem dos elementos for importante para o
    aplicativo, uma classe diferente, como LinkedHashSet, pode ser mais
    apropriada.

    - Iteração lenta: a iteração sobre os elementos do HashSet pode ser mais
    lenta do que em outras implementações da interface Set, como TreeSet ou
    LinkedHashSet, pois não há nenhuma ordem definida.

    - Consumo de memória: a classe HashSet pode consumir mais memória do que
    outras implementações da interface Set, especialmente quando há muitos
    elementos na coleção.

    - Possibilidades de sobrecarregar tabela hash: Em algumas circunstâncias,
    a tabela de hash pode ficar sobrecarregada, resultando em uma diminuição
    no desempenho das operações de conjunto.

    - Não sincronizada aumentando probabilidade de condição de corrida: A classe
    não é sincronizada, ou seja, se precisar acessá-la a partir de várias threads,
    devemos garantir as operações de sincronização manualmente ou usar a classe
    ConcurrentHashMap.


---> Pontos importantes e atenções a se tomar:

    1o - Não é thread-safe: a classe HashSet não é sincronizada, o que significa
    que não é segura para uso em ambientes concorrentes sem a devida sincronização.

    2o - Não mantém ordem de inserção: o HashSet não mantém uma ordem específica
    dos elementos, o que significa que a ordem em que os elementos são inseridos
    pode não ser a ordem em que são iterados.

    3o - Não permite elementos duplicados: o HashSet não permite elementos
    duplicados. Se um elemento duplicado for adicionado à coleção, a operação
    será ignorada.

    4o - Aceita elementos nulos: o HashSet permite a adição de elementos nulos,
    mas é importante lembrar que a comparação de elementos nulos é diferente da
    comparação de outros elementos.

    5o - Desempenho pode ser afetado pelo fator de carga: o desempenho da classe
    HashSet pode ser afetado pelo fator de carga da tabela hash. É recomendado
    manter o fator de carga abaixo de 0,75 para um desempenho ideal.

    6o - O método equals() é utilizado para comparar elementos: o HashSet utiliza
    o método equals() para comparar elementos, o que significa que os elementos
    adicionados devem implementar este método corretamente.

    7o - Hashcode: o HashSet usa o método hashCode() para determinar a posição
    do elemento na tabela de hash. Certifique-se de que a classe do objeto tenha
    implementado corretamente este método.

    8o - A classe HashSet pode ser utilizada como base para outras implementações:
    a classe HashSet pode ser utilizada como base para outras implementações de
    conjuntos, como LinkedHashSet e TreeSet.

    9o - Adicionar elementos: você pode adicionar elementos ao HashSet usando o
    método add(). O método retorna true se o elemento foi adicionado com sucesso
    e false se o elemento já estava presente no conjunto.

    10o - Performance: o HashSet tem um desempenho melhor em operações de adição,
    remoção e busca do que a maioria das outras estruturas de dados em Java, como
    o ArrayList. No entanto, o desempenho pode ser afetado se a função hashCode()
    não for bem implementada ou se houver muitas colisões.

-------------------------------------------------------------------------------
* Class LinkedHashSet: A classe é uma implementação da interface Set em Java que usa
uma lista duplamente encadeada para armazenar os elementos na ordem em que foram
inseridos, além de garantir que não há elementos duplicados no conjunto.
Ela herda as características da classe HashSet e adiciona a capacidade de manter
a ordem dos elementos inseridos.

- Resolve problema anterior da classe Hashset, garantindo a ordem de inserção dos
elementos na ordem em que foram adicionados.

- Algumas aplicações e utilidades da classe LinkedHashSet em Java incluem:

    - Manter a ordem de inserção dos elementos: Como mencionado anteriormente,
    a classe LinkedHashSet mantém a ordem dos elementos inseridos, o que pode
    ser útil em muitos casos.

    - Remoção de elementos: Quando você remove um elemento de um LinkedHashSet,
    ele é removido da lista na ordem em que foi inserido.

    - Eliminação de elementos duplicados: Como qualquer conjunto em Java, um
    LinkedHashSet garante que não há elementos duplicados no conjunto.

    - Criação de uma cópia ordenada de um conjunto: Se você deseja criar uma
    cópia ordenada de um conjunto em Java, você pode usar um LinkedHashSet
    para armazenar os elementos na ordem em que foram inseridos.

    - Implementação de cache: Um LinkedHashSet pode ser usado como uma
    implementação simples de cache, onde os elementos mais recentemente
    acessados são mantidos no topo da lista.

    - Implementação de históricos: Um LinkedHashSet pode ser usado para manter
    um histórico de ações ou eventos em ordem cronológica, onde os elementos
    mais recentes são adicionados no topo da lista.

    - Desempenho: A classe LinkedHashSet tem um desempenho semelhante ao da
    classe HashSet em termos de adição, remoção e verificação da presença de
    elementos. No entanto, o desempenho da iteração é um pouco mais lento,
    pois a classe LinkedHashSet precisa percorrer a lista duplamente encadeada
    para manter a ordem dos elementos.

Em resumo, a classe LinkedHashSet é uma excelente escolha quando você precisa
manter a ordem de inserção dos elementos, remover elementos da lista na ordem
em que foram inseridos ou garantir que não há elementos duplicados no conjunto.

- Vantagens:

    - Mantém a ordem de inserção dos elementos: Mantém a ordem em que os
    elementos foram inseridos no conjunto.
    Isso pode ser útil em várias situações, como quando você precisa exibir os
    elementos em ordem cronológica.

    - Evita duplicatas: Evita a inserção de elementos duplicados no conjunto.
    Isso pode ser útil quando você precisa garantir que cada elemento no
    conjunto seja único.

    - Implementação eficiente: É uma implementação eficiente da interface Set
    em Java. As operações de adição, remoção e busca de elementos são muito
    rápidas, pois a classe usa um hash table internamente.

    - Iteração ordenada é garantida: Permite iterar sobre os elementos do conjunto
    na ordem em que foram inseridos.
    Isso pode ser útil quando você precisa exibir ou processar os elementos em
    uma ordem específica.

    - Funcionalidades adicionais: Oferece vários métodos adicionais, como o método
    clone() para criar uma cópia do conjunto e o método removeAll() para remover
    vários elementos de uma só vez.

    - Permite a fácil conversão entre tipos de coleções: o LinkedHashSet implementa
    a interface Set, o que significa que é fácil converter de um LinkedHashSet para
    outras implementações de Set ou vice-versa, como o HashSet, o TreeSet, etc.

    - É eficiente para remover elementos: a remoção de elementos em um LinkedHashSet
    é muito eficiente, pois a posição do elemento na lista vinculada é conhecida e,
    portanto, pode ser removido rapidamente.

    - Permite iterar os elementos em ordem crescente ou decrescente: o LinkedHashSet
    possui métodos que permitem a iteração dos elementos em ordem crescente ou
    decrescente, facilitando a implementação de algumas funcionalidades que exigem a
    ordenação dos elementos.

- Desvantagens:

    - Maior consumo de memória: o LinkedHashSet precisa armazenar os elementos em
    uma lista vinculada além de manter um mapa hash para realizar as operações de
    busca.
    Isso pode resultar em um consumo de memória maior em comparação com outras
    implementações de Set.

    - Pode ter uma performance pior em comparação com HashSet para algumas operações:
    embora o LinkedHashSet tenha uma performance similar ao HashSet para adicionar,
    remover e buscar elementos, ele pode ter uma performance um pouco pior em alguns
    casos devido à necessidade de manter a ordem dos elementos.

    - Iteração é mais lenta do que em uma lista simples: embora o LinkedHashSet
    possua uma ordem de inserção dos elementos, a iteração é um pouco mais lenta
    do que em uma lista simples, devido à necessidade de verificar a tabela hash
    antes de retornar cada elemento.

    - Não é thread-safe: assim como outras implementações da interface Set, o
    LinkedHashSet não é thread-safe, ou seja, não é seguro utilizá-lo em ambientes
    concorrentes sem a devida sincronização.

    - Não é recomendado para elementos grandes: o LinkedHashSet pode ter uma
    performance ruim para elementos muito grandes, pois o processo de hash para
    estes elementos pode ser mais lento. Nesse caso, pode ser mais adequado
    utilizar outras estruturas de dados.

---> Pontos importantes e atenções a se tomar:

    1o - A ordem dos elementos é mantida: uma das principais características do
    LinkedHashSet é a manutenção da ordem de inserção dos elementos. É importante
    lembrar que a ordem dos elementos pode mudar se um elemento já existente for
    adicionado novamente.

    2o - Não permite elementos duplicados: o LinkedHashSet não permite a inclusão
    de elementos duplicados. Ao tentar adicionar um elemento duplicado, a operação
    de adição falhará silenciosamente e não terá efeito.

    3o - Não é sincronizado: o LinkedHashSet não é thread-safe, portanto, se for
    usado em um ambiente concorrente, será necessário sincronizar manualmente as
    operações para evitar condições de corrida.

    4o - Pode ter um consumo de memória maior: como mencionado anteriormente, o
    LinkedHashSet pode ter um consumo de memória maior do que outras implementações
    de Set, especialmente se muitos elementos forem adicionados.

    5o - O desempenho pode ser afetado por elementos grandes: a performance do
    LinkedHashSet pode ser afetada negativamente se muitos elementos grandes forem
    adicionados, pois o processo de hash para estes elementos pode ser mais lento.

    6o - Iteração pode ser mais lenta do que em uma lista simples: embora a iteração
    seja ordenada, ela pode ser um pouco mais lenta do que em uma lista simples,
    devido à necessidade de verificar a tabela hash antes de retornar cada elemento.

    7o - Escolha cuidadosamente a implementação do Set: dependendo da aplicação,
    outras implementações de Set podem ser mais adequadas do que o LinkedHashSet.
    Por exemplo, se não for necessário manter a ordem de inserção, o HashSet pode
    ser uma escolha melhor devido a sua performance mais rápida.

    8o - Pode ser inicializado com uma capacidade e fator de carga: ao criar um
    LinkedHashSet, é possível especificar a capacidade inicial e o fator de carga.
    Isso pode ser útil para evitar realocações de memória frequentes e melhorar a
    performance em casos em que o tamanho do conjunto é conhecido com antecedência.

    9o - Pode ser utilizado em conjunto com outras estruturas de dados: LinkedHashSet
    pode ser utilizado em conjunto com outras estruturas de dados para resolver
    problemas mais complexos. Por exemplo, ele pode ser utilizado para remover
    elementos duplicados de uma lista enquanto mantém a ordem de inserção.

    10o - Pode ser utilizado para implementar algoritmos de cache: o LinkedHashSet
    pode ser utilizado para implementar algoritmos de cache simples. Ao adicionar
    um elemento a ele, é possível verificar se o tamanho do conjunto excede um
    determinado limite e remover o elemento mais antigo se necessário.

    11o - Não é adequado para elementos mutáveis: o LinkedHashSet utiliza o hash do
    objeto para determinar sua posição na tabela hash. Portanto, se um objeto mutável
    for utilizado como elemento do LinkedHashSet, seu hash pode mudar e causar
    problemas de desempenho ou comportamento inesperado.

    12o - As operações de adição, remoção e busca são rápidas: as operações de adição,
    remoção e busca no LinkedHashSet têm complexidade O(1) em média. No entanto, em
    casos raros, a complexidade pode ser O(n), dependendo da forma como a tabela hash
    é construída e dos elementos que estão sendo armazenados.

-------------------------------------------------------------------------------
* Interface SortedSet: Ela extends a interface Set e define um conjunto
ordenado de elementos únicos. Como o nome sugere, um SortedSet mantém os
elementos em ordem classificada e não permite elementos duplicados.
A ordem pode ser definida de várias maneiras, dependendo da implementação, como
a ordem natural dos elementos ou uma ordem definida por um comparador externo.

As classes que implementam essa interface fornecem funcionalidades adicionais em
relação à interface Set, como acesso aos elementos por posição e subconjuntos
definidos por um intervalo de elementos.

Em geral, o uso de classes que implementam a interface SortedSet pode ser uma boa
escolha em aplicações que exigem a ordenação automática de elementos e acesso
eficiente a subconjuntos de elementos.

- Algumas das principais aplicações e utilidades de um SortedSet são:

    - Ordenação de elementos: um SortedSet pode ser usado para manter os elementos
    em ordem classificada, o que pode ser útil em várias aplicações, como
    classificação de dados, exibição de informações em ordem alfabética, filtragem
    de dados com base em uma ordem definida e assim por diante.

    - Conjunto sem duplicatas: um SortedSet não permite elementos duplicados, o que
    pode ser útil em muitos casos em que é importante garantir que não haja duplicatas
    em um conjunto de dados.

    - Eficiência de busca: as implementações de SortedSet usam uma estrutura interna,
    como uma árvore binária de busca ou uma tabela hash, para manter os elementos em
    ordem e pesquisar rapidamente um elemento em particular.
    Isso torna a busca de elementos em um SortedSet muito eficiente em comparação com
    outras estruturas de dados.

    - Subconjuntos ordenados: um SortedSet permite a criação de subconjuntos ordenados
    de seus elementos, usando os métodos subSet, headSet e tailSet.
    Isso pode ser útil em várias aplicações, como busca por um intervalo específico de
    valores, seleção de uma faixa de dados com base em uma condição de filtro e assim
    por diante.

Em resumo, um SortedSet é uma estrutura de dados útil para manter um conjunto ordenado
de elementos únicos. Ele pode ser usado em uma variedade de aplicações que exigem
eficiência de busca, ordenação de elementos e a garantia de que não haja duplicatas.

---> Principais Classes que Implementam ele:

    * TreeSet: implementa um SortedSet usando uma árvore binária de busca. Os elementos
    são mantidos em ordem natural ou em uma ordem definida por um Comparator externo.
    - É útil quando se precisa manter uma coleção de elementos em ordem classificada.
    Por exemplo, pode ser usado para manter um conjunto de palavras em ordem alfabética
    ou para classificar e filtrar dados.

    * ConcurrentSkipListSet: implementa um SortedSet usando uma lista ligada de nós,
    cada um contendo uma chave e um conjunto de nós adjacentes. A lista é ordenada
    usando a ordem natural dos elementos ou um Comparator externo.
    - É útil quando é necessário manter uma lista ordenada de elementos em um ambiente
    multithreaded. Por exemplo, pode ser usado para manter uma lista de threads em
    execução em ordem de prioridade.

    * EnumSet: implementa um SortedSet para enumerações, mantendo os elementos em
    ordem natural da enumeração.
    - É útil para representar conjuntos de enumerações em um programa. Por exemplo,
    pode ser usado para representar os dias da semana ou os estados de uma máquina
    de estados finita.

    * CopyOnWriteArraySet: implementa um SortedSet usando um array de objetos.
    A estrutura interna do array é modificada de forma thread-safe usando uma
    cópia do array original.
    É útil quando é necessário manter uma coleção thread-safe de elementos,
    especialmente em ambientes em que as leituras são muito mais frequentes
    do que as gravações. Por exemplo, pode ser usado para manter uma lista
    de assinantes de eventos em um aplicativo.

- Vantagens:

    - Ordenação automática: A principal vantagem de usar uma classe que implementa
    a interface SortedSet é que os elementos são automaticamente ordenados na ordem
    definida pela classe.
    Isso pode economizar tempo e esforço para ordenar os elementos manualmente.

    - Operações mais eficientes: As classes que implementam a interface SortedSet
    oferecem operações de busca e acesso a elementos mais eficientes do que outras
    classes de conjunto, como HashSet.
    Isso é possível graças à ordenação dos elementos.

    - Conjuntos limitados por intervalo: As classes que implementam a interface
    SortedSet permitem criar subconjuntos com base em um intervalo de elementos.
    Isso pode ser útil em várias aplicações, como em jogos de cartas ou em
    visualização de dados.

    - Redução de código: A ordenação automática dos elementos pode reduzir a
    quantidade de código necessário para realizar tarefas comuns em que a
    ordenação é necessária, como em algoritmos de pesquisa binária.

- Desvantagens:

    - Desempenho inferior em inserção e remoção: As classes que implementam a
    interface SortedSet geralmente têm um desempenho inferior em operações de
    inserção e remoção de elementos em relação a outras classes de conjunto,
    como HashSet.
    Isso ocorre porque a ordenação dos elementos precisa ser mantida e
    atualizada durante essas operações.

    - Complexidade do código: A implementação de classes que usam a interface
    SortedSet pode ser mais complexa do que a implementação de classes que usam
    outras interfaces de conjunto, devido à necessidade de manter a ordenação
    dos elementos.

    - Custo computacional: A ordenação automática dos elementos pode ter um custo
    computacional mais alto do que outras implementações de conjunto.
    Isso pode ser um problema em aplicações que requerem desempenho de alto nível
    e grande volume de dados.

---> Diferenças de uso para cada classe que implementa:

* TreeSet:
    - Implementação baseada em árvore binária balanceada (Red-Black Tree);
    - Mantém os elementos em ordem crescente;
    - Fornece métodos adicionais para trabalhar com elementos em uma posição específica na ordem;
    - É adequada para casos em que é necessário manter os elementos em ordem crescente.

* ConcurrentSkipListSet:
    - Implementação baseada em uma estrutura de dados de lista ligada parcialmente ordenada;
    - Mantém os elementos em ordem crescente;
    - Permite acesso concorrente seguro aos elementos do conjunto;
    - É adequada para casos em que há múltiplas threads trabalhando simultaneamente no conjunto.

* ImmutableSortedSet:
    - Implementação imutável de um conjunto ordenado de elementos;
    - Mantém os elementos em ordem crescente;
    - Não permite a adição, remoção ou modificação de elementos após a criação;
    - É adequada para casos em que os elementos são conhecidos antecipadamente e não serão modificados.

---> Pontos importantes e atenções em comum entre elas:

    1o - Ordenação: A interface SortedSet define uma ordem total sobre seus elementos,
    que pode ser definida por meio de um comparador ou pela ordem natural dos elementos.
    As classes que implementam essa interface devem garantir que os elementos sejam
    armazenados em ordem crescente ou decrescente, de acordo com a ordem definida.

    2o - Duplicatas: Como a interface Set, a interface SortedSet não permite elementos
    duplicados. Se um elemento que já existe no conjunto é adicionado, o método add()
    não tem efeito. (return false);

    3o - Métodos de acesso: Além dos métodos padrão da interface Set, a interface
    SortedSet possui métodos adicionais para acessar os elementos com base em sua
    posição na ordem. Esses métodos incluem first(), last(), headSet(), tailSet()
    e subSet().

    4o - Imutabilidade: A interface SortedSet é imutável, o que significa que seus
    elementos não podem ser modificados depois de adicionados ao conjunto. Se um
    elemento precisar ser modificado, ele deve ser removido do conjunto e adicionado
    novamente com a nova versão.

    5o - Performance: As classes que implementam a interface SortedSet geralmente
    têm um desempenho melhor do que outras estruturas de dados que suportam a
    ordenação, como ArrayList ou LinkedList. Isso ocorre porque as implementações
    SortedSet podem usar árvores de busca balanceadas para armazenar os elementos
    e manter a ordem.

    6o - Comparador: As classes que implementam a interface SortedSet podem permitir
    que o programador especifique um comparador personalizado para definir a ordem
    dos elementos. Se nenhum comparador for especificado, a ordem natural dos elementos
    será usada.

    7o - Elementos nulos: A interface SortedSet não permite elementos nulos. Se um
    elemento nulo é adicionado, o método add() lança uma exceção NullPointerException.

    8o - Iteração: A iteração dos elementos em uma SortedSet ocorre na ordem definida
    pela interface.
    Isso significa que os elementos são acessados em ordem crescente ou decrescente,
    dependendo da ordem definida.

    9o - Subconjuntos imutáveis: Além dos métodos de acesso mencionados acima, a
    interface SortedSet também possui métodos que retornam subconjuntos imutáveis
    do conjunto original. Esses subconjuntos mantêm a ordem dos elementos e podem
    ser usados para realizar operações em um subconjunto específico do conjunto
    original.

    10o - Implementações padrão: O Java fornece duas implementações padrão SortedSet:
    TreeSet e ConcurrentSkipListSet.
    O TreeSet armazena os elementos em uma árvore balanceada e é thread-safe, enquanto
    o ConcurrentSkipListSet usa uma lista vinculada paralela e também é thread-safe.

    11o - Baixa performance de inserção: Embora a interface SortedSet tenha um bom
    desempenho para acessar os elementos, a inserção pode ser lenta em comparação
    com outras estruturas de dados, especialmente quando muitos elementos são
    adicionados.
    Isso ocorre porque a inserção em uma árvore balanceada requer que a árvore seja
    reequilibrada para manter sua estrutura.

    12o - Desempenho de busca: A busca em uma árvore balanceada tem uma complexidade
    de tempo logarítmica, o que significa que o tempo de busca aumenta lentamente à
    medida que o tamanho do conjunto aumenta.
    Isso torna as classes que implementam a interface SortedSet uma boa escolha para
    conjuntos grandes que precisam ser acessados com frequência.

-------------------------------------------------------------------------------
* Interface NavigableSet: É uma subinterface da interface SortedSet que foi introduzida
no Java 6. Essa interface extends a interface SortedSet e adiciona vários métodos que
permitem navegar pelos elementos do conjunto em ordem.

- Alguns dos métodos adicionados pela interface NavigableSet incluem:

    - lower(e): retorna o maior elemento estritamente menor do que o elemento especificado. (<)
    - floor(e): retorna o maior elemento menor ou igual ao elemento especificado. (<=)
    - higher(e): retorna o menor elemento estritamente maior do que o elemento especificado. (>)
    - ceiling(e): retorna o menor elemento maior ou igual ao elemento especificado. (>=)
    - pollFirst(): remove e retorna o primeiro elemento do conjunto.
    - pollLast(): remove e retorna o último elemento do conjunto.

A interface NavigableSet é implementada pela classe TreeSet do Java, que é uma das
implementações mais comuns da interface SortedSet. É importante notar que a interface
NavigableSet é compatível com as APIs da interface SortedSet e da interface Set, o que
significa que qualquer código que use essas interfaces pode ser facilmente atualizado
para usar a interface NavigableSet, se necessário.

---> Principais Classes que Implementam ele:

    * TreeSet: É uma classe que implementa a interface SortedSet e também a interface
    NavigableSet. Ela mantém seus elementos em ordem, o que é determinado por um
    comparador. Além dos métodos da interface SortedSet, a classe TreeSet também
    suporta os métodos adicionais da interface NavigableSet, que permitem uma navegação
    mais precisa pelos elementos do conjunto em ordem. A classe TreeSet é implementada
    como uma árvore rubro-negra, o que significa que suas operações são geralmente
    rápidas e têm um desempenho previsível.

    * ConcurrentSkipListSet: É uma classe que implementa a interface SortedSet e também
    a interface NavigableSet. Ela é semelhante à classe TreeSet, mas é projetada para uso
    em ambientes concorrentes, ou seja, em cenários onde vários threads estão acessando e
    modificando o conjunto simultaneamente. A classe ConcurrentSkipListSet é implementada
    como uma lista vinculada, o que permite que ela suporte operações de inserção, remoção
    e acesso rápido em ambientes concorrentes.

Ambas as classes, TreeSet e ConcurrentSkipListSet, são úteis quando se precisa manter uma
coleção de elementos ordenados e permitir a navegação precisa pelos elementos. A escolha
entre as duas classes depende principalmente das necessidades de desempenho e concorrência.
Se a aplicação não precisa suportar operações concorrentes, a classe TreeSet pode ser uma
opção mais simples e eficiente. Já se a aplicação precisa suportar operações concorrentes,
a classe ConcurrentSkipListSet é uma opção mais adequada.

---> Pontos importantes e atenções (REMOVENDO pontos especificados nas superInterfaces dele):

    1o - Métodos de navegação: Como mencionado anteriormente, a interface NavigableSet oferece
    métodos adicionais de navegação, como lower(), floor(), ceiling() e higher(). Esses métodos
    permitem que você navegue pela coleção com mais precisão e eficiência.

    2o - Subconjuntos navegáveis: Permite criar subconjuntos da coleção com base em faixas
    de valores e navegar nesses subconjuntos. Essa funcionalidade é especialmente útil para
    operações de busca e remoção em um determinado intervalo de valores.

    3o - Métodos adicionais de remoção: Oferece métodos adicionais de remoção, como pollFirst()
    e pollLast(), que permitem remover e retornar o primeiro ou o último elemento da coleção.

    4o - Métodos de deslocamento: Oferece métodos de deslocamento, como lowerKey(), floorKey(),
    ceilingKey() e higherKey(), que permitem encontrar as chaves correspondentes aos valores
    retornados pelos métodos de navegação.

    5o - Iteração em ordem reversa: Oferece um método para iterar pelos elementos em ordem
    reversa, o que pode ser útil em certas situações.

-------------------------------------------------------------------------------
* Class TreeSet: É uma implementação da interface SortedSet/NavigableSet que usa
uma árvore binária balanceada para armazenar os elementos em ordem crescente.
Ela é uma das classes mais utilizadas do Java Collections Framework devido à sua
eficiência em manter uma coleção ordenada de elementos.

- Algumas das aplicações e utilidades da classe TreeSet no Java incluem:

    - Ordenação: A classe TreeSet é particularmente útil quando você precisa armazenar
    elementos em ordem crescente ou decrescente.
    Isso pode ser útil em várias aplicações, como ordenação de dados de entrada ou
    classificação de resultados.

    - Conjunto de valores exclusivos: Como a classe TreeSet é uma implementação da
    interface Set, ela garante que cada elemento seja único na coleção.
    Isso é útil quando você precisa de uma coleção de valores exclusivos, como em um
    conjunto de palavras-chave ou em um conjunto de nomes de usuários em um sistema
    de autenticação.

    - Intervalos de valores: Como a classe TreeSet implementa a interface NavigableSet,
    ela permite que você busque elementos na coleção com base em intervalos de valores,
    o que pode ser útil em várias aplicações, como buscas por faixas de preços em um
    sistema de comércio eletrônico.

    - Implementação de Mapas ordenados: A classe TreeSet pode ser usada para implementar
    um mapa ordenado, em que as chaves são mantidas em ordem. Isso é possível porque a
    classe TreeSet permite que você armazene pares de chave-valor em um objeto e busque
    esses pares com base na chave.

    - Implementação de conjuntos thread-safe: A classe ConcurrentSkipListSet é uma
    implementação da interface NavigableSet que é thread-safe, o que significa que
    pode ser usada em ambientes concorrentes sem preocupações com sincronização.
    Isso é útil em várias aplicações em que várias threads podem acessar a mesma
    coleção simultaneamente.

    - Busca Binária: O TreeSet é uma estrutura de dados comum para implementar
    algoritmos como a busca binária e a verificação da presença de elementos em
    uma lista ordenada.

Em resumo, a classe TreeSet é muito útil para armazenar e manipular coleções ordenadas
e elementos, além de ser eficiente em várias operações de busca e navegação.

- Vantagens:

    - Ordenação automática: Mantém seus elementos automaticamente em ordem classificada,
    o que pode ser conveniente e útil em muitos casos.

    - Velocidade de acesso: Permite pesquisas eficientes, com complexidade O(log n),
    o que é importante para aplicações com grande quantidade de dados.

    - Detecção de duplicatas: Não permite elementos duplicados, o que pode ser útil para
    garantir que uma coleção de elementos não contenha valores repetidos.

    - Flexibilidade: Pode ser usado com qualquer objeto que implemente a interface
    Comparable ou com um Comparator personalizado, o que permite que ele seja adaptado
    para diferentes tipos de objetos e requisitos de classificação.

    - Eficiência na obtenção de subconjuntos: Permite a obtenção de subconjuntos da
    árvore com base em faixas de valores de forma eficiente, usando o método
    subSet(E fromElement, E toElement), o que pode ser útil em muitos casos.

- Desvantagens:

    - Desempenho: É menos eficiente do que outras estruturas de dados, como o HashSet,
    em algumas operações, como adicionar e verificar a existência de elementos.

    - Requisito de memória: Pode ser menos eficiente em termos de uso de memória do que
    outras estruturas de dados, especialmente se for usado com objetos grandes ou se a
    árvore for muito grande.

    - Dificuldade de alterar a ordem: É uma estrutura de dados imutável, o que significa
    que uma vez que os elementos são adicionados, sua ordem não pode ser facilmente
    alterada, o que pode ser um problema em algumas situações.

    - Menor eficiência na adição e remoção de elementos: Pode ser menos eficiente na
    adição e remoção de elementos do que outras estruturas de dados, como o ArrayList,
    especialmente para grandes conjuntos de dados.

---> Pontos importantes e atenções a se tomar:

    1o - Não permite elementos duplicados: É importante lembrar que o TreeSet não permite
    a inserção de elementos duplicados. Ao tentar adicionar um elemento que já existe na
    árvore, a operação não terá efeito e o tamanho da árvore não será alterado.

    2o - Implementação do Comparable ou Comparator: Para usar um TreeSet com objetos
    personalizados, é necessário implementar a interface Comparable ou fornecer um
    Comparator personalizado. Sem isso, o TreeSet não saberá como comparar os objetos
    e lançará uma exceção.

    3o - Cuidado ao trabalhar com objetos mutáveis: Ao trabalhar com objetos mutáveis,
    é importante lembrar que a ordem dos elementos pode ser afetada se o objeto for
    alterado após ser adicionado ao TreeSet. É recomendado usar objetos imutáveis ou
    fazer uma cópia do objeto antes de adicioná-lo à árvore.

    4o - Menos Eficiência da inserção e remoção: Pode ser menos eficiente na inserção e
    remoção de elementos do que outras estruturas de dados, como o ArrayList. Portanto,
    é importante avaliar cuidadosamente as necessidades do aplicativo e escolher a
    estrutura de dados apropriada.

    5o - Cuidado ao iterar sobre a árvore: Ao iterar sobre a árvore, é importante lembrar
    que os elementos serão retornados em ordem classificada. Se a ordem de iteração não
    for importante, pode ser mais eficiente usar outra estrutura de dados.

    6o - Acesso rápido a elementos com base em valores: Permite o acesso rápido a elementos
    com base em valores usando o método higher(E e) e lower(E e), que retornam o primeiro
    elemento maior ou menor que um valor específico. Este recurso pode ser útil em muitos
    casos.

    7o - Eficiência de busca rápida: É eficiente em busca rápida, com uma complexidade de
    tempo média de O(log n). Portanto, pode ser uma boa escolha para situações em que a
    busca rápida é importante.

    8o - Sobrecarga de memória: Pode consumir mais memória do que outras estruturas de dados,
    especialmente para conjuntos grandes ou para objetos complexos.
    Isso ocorre porque a árvore interna mantém referências a todos os elementos inseridos, o
    que pode levar a uma sobrecarga de memória se os objetos forem grandes ou se houver muitos
    deles.

    9o - Desempenho inferior para operações em massa: Pode ser menos eficiente para operações
    em massa, como adicionar um grande número de elementos de uma vez ou limpar o conjunto
    inteiro. Nestes casos, pode ser mais eficiente usar outra estrutura de dados.

    10o - Limitação na busca por índice: Não permite a busca por índice, ou seja, não há um
    método para acessar um elemento em uma posição específica na árvore. Se a busca por índice
    for um requisito, pode ser necessário usar outra estrutura de dados, como o ArrayList.

    11o - Desempenho inferior para iteração em ordem inversa: Pode ser menos eficiente para
    iteração em ordem inversa, pois não suporta um método para iterar em ordem reversa.
    Para iterar em ordem inversa, pode ser necessário criar uma cópia do conjunto e
    invertê-lo manualmente.

-------------------------------------------------------------------------------
* Interface Map: Representa uma estrutura de dados que mapeia chaves para valores.
Em outras palavras, um Map permite armazenar pares de valores (chave-valor), onde
cada chave é única e corresponde a um único valor. O Java fornece várias implementações
da interface Map, incluindo HashMap, TreeMap, LinkedHashMap, EnumMap e ConcurrentHashMap.

O Map é amplamente utilizado em Java para armazenar e recuperar valores com base em
uma chave. Algumas das aplicações comuns do Map são:

    - Armazenar configurações do aplicativo: um Map pode ser usado para armazenar
    configurações do aplicativo, onde a chave é o nome da configuração e o valor é
    o valor da configuração.
    Isso permite que as configurações sejam facilmente acessadas e alteradas em
    tempo de execução.

    - Armazenar informações do usuário: um Map pode ser usado para armazenar
    informações do usuário, onde a chave é o ID do usuário e o valor é o objeto
    User que contém informações sobre o usuário.

    - Cache de dados: um Map pode ser usado como um cache de dados, onde as chaves
    são consultas de banco de dados e os valores são os resultados dessas consultas.
    Isso permite que as consultas sejam executadas apenas uma vez e os resultados
    sejam armazenados em cache para acesso rápido posterior.

    - Contagem de ocorrências: um Map pode ser usado para contar o número de
    ocorrências de um determinado item em uma lista. A chave pode ser o item
    e o valor pode ser o número de ocorrências desse item na lista.

    - Indexação: um Map pode ser usado para indexar itens em uma coleção com
    base em uma determinada propriedade. Por exemplo, um Map pode ser usado
    para indexar objetos Person com base em seu sobrenome, onde a chave é o
    sobrenome e o valor é uma lista de objetos Person com esse sobrenome.

Essas são apenas algumas das aplicações comuns do Map em Java. A flexibilidade e poder
do Map tornam-no uma estrutura de dados muito útil para uma variedade de casos de uso.

- Cuidados ao utilizar métodos polimorficos que esperam Collections, pois o Map
não é uma!

- NÃO podemos duplicar chaves, ou seja as chaves é o ID do valor portanto elas devem
ser únicas.

---> Principais Classes que Implementam ele:

    * HashMap: É uma das implementações mais comuns e amplamente utilizadas da interface
    Map. Ele armazena as chaves e valores em uma tabela de hash, que é uma estrutura de
    dados que permite a busca, inserção e remoção de elementos em tempo constante O(1)
    em média. O HashMap não garante a ordem de inserção dos elementos e permite que chaves
    e valores nulos sejam armazenados. Ele é adequado para situações em que a ordem dos
    elementos não é importante e um alto desempenho é desejado.

    * TreeMap: É uma implementação de Map baseada em árvore binária de busca, que armazena
    as chaves e valores em uma estrutura de árvore balanceada. Os elementos são ordenados
    de acordo com a ordem natural dos seus valores ou por um comparador personalizado.
    O TreeMap é adequado para situações em que a ordenação dos elementos é importante e
    uma estrutura de dados de árvore balanceada é desejada. No entanto, devido à
    complexidade da árvore binária, as operações de inserção, remoção e pesquisa têm um
    tempo de execução médio de O(log n).

    * LinkedHashMap: É uma implementação de Map que mantém a ordem de inserção dos elementos.
    Ele armazena as chaves e valores em uma tabela de hash, mas também mantém uma lista
    duplamente ligada que preserva a ordem de inserção. O LinkedHashMap é adequado para
    situações em que a ordem dos elementos é importante e é necessário iterar sobre os
    elementos na ordem em que foram inseridos.

    * ConcurrentHashMap: É uma implementação de Map otimizada para uso concorrente, onde
    várias threads podem acessar a estrutura de dados ao mesmo tempo. Ele usa técnicas
    de bloqueio de segmento e compartilhamento de leitura para permitir operações
    simultâneas de leitura e gravação, tornando-o adequado para ambientes de thread
    múltiplo. O ConcurrentHashMap é altamente escalável e tem um desempenho melhor do
    que outras implementações de Map em situações de concorrência.

    * EnumMap: É uma implementação de Map otimizada para enumerações. Ele armazena as
    chaves como as constantes de uma enumeração específica e os valores associados
    a cada chave são do tipo específico da enumeração. O EnumMap é altamente eficiente
    e é adequado para situações em que as chaves são restritas a uma enumeração específica.
    Ele garante a ordem de iteração de acordo com a ordem natural das constantes da enumeração.

- Vantagens:

    - Permite armazenar e recuperar dados em pares chave-valor.

    - Suporta a busca rápida de valores a partir de uma chave, o que é ideal para
    aplicativos que precisam de alta velocidade de acesso aos dados.

    - Possibilita a remoção e atualização de elementos com facilidade e eficiência.

    - Oferece diversas implementações para atender diferentes requisitos de
    desempenho e funcionalidade.

    - Pode ser utilizado para representar e manipular informações de forma
    organizada e estruturada.

    - É uma estrutura de dados muito versátil e amplamente utilizada em várias
    aplicações.

- Desvantagens:

    - Não garante a ordem de inserção dos elementos (exceto o LinkedHashMap).

    - Não permite a existência de chaves duplicadas.

    - A escolha da implementação correta pode ser difícil, pois cada uma possui
    seus próprios recursos e limitações.

    - Pode ser menos eficiente em situações em que os dados são armazenados em
    grande quantidade ou quando a estrutura de dados é atualizada com frequência.

    - Se a implementação não estiver configurada corretamente, pode causar
    problemas de segurança, como vulnerabilidades de injeção de código
    malicioso.

---> Diferenças de uso para cada classe que implementa:

    * HashMap: Baseada em tabela de dispersão, que é altamente eficiente para
    operações de inserção, remoção e busca. Não garante a ordem de inserção dos
    elementos, mas permite que as chaves sejam nulas. É ideal para aplicações
    que precisam de alta velocidade de acesso aos dados e não precisam manter
    a ordem de inserção dos elementos.

    * TreeMap: Baseada em árvore binária de busca, que mantém os elementos em
    ordem de acordo com a chave.
    Isso significa que os elementos são sempre classificados em ordem crescente
    ou decrescente da chave. É ideal para aplicações que exigem que os elementos
    sejam mantidos em ordem ou precisam realizar operações de intervalo com os
    dados.

    * LinkedHashMap: Mantém a ordem de inserção dos elementos.
    Isso significa que os elementos são sempre recuperados na mesma ordem em
    que foram inseridos no mapa. É ideal para aplicações que precisam manter
    a ordem de inserção dos elementos e exigem alta velocidade de acesso aos
    dados.

    * ConcurrentHashMap: Suporta acesso concorrente em aplicativos multithread.
    Ele divide o mapa em vários segmentos, permitindo que diferentes threads
    acessem diferentes segmentos de forma concorrente, sem bloquear tôdô o mapa.
    Isso o torna altamente escalável e eficiente para aplicativos com muitos
    threads. No entanto, a ordem de inserção dos elementos não é garantida.

    * WeakHashMap: Permite que as chaves sejam coletadas pelo coletor de lixo
    do Java quando não são mais usadas no aplicativo.
    Isso pode ser útil em aplicativos que precisam controlar o uso de memória
    e evitar vazamentos de memória.

    * IdentityHashMap: Usa o endereço de memória da chave em vez de seu valor
    para determinar a igualdade das chaves.
    Isso significa que dois objetos com o mesmo valor podem ser tratados como
    chaves distintas se tiverem endereços de memória diferentes.
    É ideal para aplicações que precisam comparar objetos por referência, em
    vez de valor.

---> Pontos importantes e atenções em comum entre elas:

    1o - Escolha as chaves e valores corretos: a escolha das chaves e valores
    corretos pode afetar significativamente o desempenho do Map. É importante
    escolher chaves que possam ser comparadas com eficiência e valores que
    possam ser recuperados com eficiência.

    2o - Verifique se a chave já existe: antes de adicionar uma chave a um Map,
    é importante verificar se ela já existe.
    Isso evita a sobrescrita de valores existentes e garante que o Map mantenha
    sua integridade.

    3o - Evite a utilização de loops para percorrer um Map: os loops podem ser
    ineficientes para percorrer um Map, especialmente se ele for grande. Em vez
    disso, utilize os métodos keySet(), entrySet() ou values() para percorrer
    um Map de forma mais eficiente.

    4o - Considere o uso de iteradores: o uso de iteradores pode ser uma maneira
    eficiente de percorrer um Map, especialmente se ele for grande ou se você
    precisar remover elementos enquanto percorre o Map.

    5o - Utilize as operações adequadas para acessar e modificar os elementos:
    cada implementação de Map fornece operações específicas para acessar e
    modificar os elementos. É importante utilizar as operações adequadas para
    garantir um uso correto e eficiente do Map.

    6o - Considere o uso de coleções imutáveis: o uso de coleções imutáveis pode
    ajudar a garantir a integridade do Map e evitar que outros objetos modifiquem
    os elementos do Map.

    7o - Considere a utilização de métodos que retornam valores opcionais: alguns
    métodos de Map retornam valores opcionais, como get(), putIfAbsent() e
    computeIfAbsent(). É importante considerar o uso desses métodos para evitar
    exceções de NullPointerException e garantir um uso correto e eficiente do Map.

    8o - Considere o uso de ConcurrentHashMap para aplicativos multithread: se
    você estiver trabalhando com aplicativos multithread, é importante considerar
    o uso de ConcurrentHashMap para garantir a integridade e consistência dos dados.

    9o - Considere o uso de bibliotecas de terceiros: existem muitas bibliotecas
    de terceiros disponíveis que fornecem implementações de Map com recursos
    adicionais, como persistência, cache e consultas. É importante considerar o
    uso dessas bibliotecas para aumentar a eficiência e a funcionalidade do Map.

    10o - Cuidado com as operações de remoção: a remoção de elementos de um Map
    pode ter um impacto significativo no desempenho, especialmente se o Map for
    grande. É importante considerar o uso de operações alternativas, como a
    marcação de elementos como inválidos, em vez de removê-los completamente.

    11o - Considere a utilização de estruturas de dados adicionais: em alguns
    casos, pode ser útil utilizar estruturas de dados adicionais em conjunto
    com Map, como filas de prioridade ou conjuntos.
    Isso pode ajudar a otimizar as operações e garantir a integridade dos dados.

    12o - Mantenha o Map atualizado: é importante manter o Map atualizado para
    garantir que ele reflita as alterações nos dados subjacentes.
    Isso pode envolver a adição ou remoção de elementos, bem como a atualização
    de valores existentes.

    13o - Considere o tamanho do Map: em alguns casos, o tamanho do Map pode
    afetar significativamente o desempenho. É importante considerar o tamanho
    do Map e escolher a implementação adequada com base nesse fator.

-------------------------------------------------------------------------------
* Class HashMap: Permite armazenar um conjunto de pares chave-valor, em que cada
chave é mapeada para um valor correspondente. Ela é usada para armazenar e recuperar
dados com base em chaves.

A principal utilidade do HashMap é permitir que se possa recuperar um valor a
partir de uma chave rapidamente. O HashMap é implementado usando uma tabela hash,
o que significa que os elementos são armazenados em uma matriz e as chaves são
mapeadas para índices nessa matriz. Essa técnica de mapeamento permite uma busca
muito rápida, independentemente do tamanho da tabela hash.

- Algumas das aplicações do HashMap incluem:

    - Armazenamento de dados em cache: Ao armazenar dados em cache em um HashMap,
    as consultas subsequentes podem ser atendidas a partir do cache, em vez de ter
    que buscar os dados em um banco de dados ou outro local de armazenamento.

    - Processamento de grandes quantidades de dados: Pode ser usado para processar
    grandes quantidades de dados, como log de eventos, de maneira rápida e eficiente.

    - Mapeamento de propriedades: É frequentemente usado para mapear propriedades,
    como configurações de aplicativos, de maneira simples e fácil de usar.

Em resumo, é uma estrutura de dados muito útil, que permite armazenar e recuperar
dados de forma eficiente, com base em chaves. É amplamente utilizada em muitas
aplicações, desde armazenamento em cache até processamento de grandes quantidades
de dados, e é uma escolha popular para armazenamento de dados em memória.

- Vantagens:

    - Eficiência: É uma das implementações mais eficientes do Map em nível mais
    baixo. Ele usa uma tabela hash para armazenar e recuperar elementos, o que
    torna as operações de busca, inserção e exclusão muito rápidas. Além disso,
    a implementação do HashMap em nível mais baixo é altamente otimizada,
    tornando-o uma opção ideal para aplicativos que exigem alto desempenho.

    - Simplicidade: Relativamente simples, pois usa uma tabela hash para armazenar
    elementos.
    Isso torna o código fácil de entender e modificar. Além disso, o HashMap é uma
    das implementações mais comuns do Map em Java, o que significa que é fácil
    encontrar exemplos e soluções de problemas on-line.

    Flexibilidade: É altamente flexível, pois permite associar qualquer tipo de
    objeto a qualquer outro objeto, desde que a chave seja única.
    Isso é muito útil quando precisamos armazenar dados que não se encaixam em
    uma matriz ou lista simples.

- Desvantagens:

    - Não é thread-safe: O que significa que pode ocorrer problemas de concorrência
    se vários threads estiverem acessando e modificando o HashMap ao mesmo tempo.
    Se a sua aplicação precisar de uma implementação thread-safe do Map, você deve
    usar uma implementação como ConcurrentHashMap.

    - Não garante ordem: Não garante a ordem dos elementos na tabela hash, o que
    significa que os elementos podem ser retornados em ordem diferente da que foram
    adicionados. Se a ordem for importante para o seu caso de uso, você deve usar
    outras implementações do Map, como o TreeMap ou o LinkedHashMap.

    - Requer chaves únicas: Requer que cada chave seja única. Se duas chaves forem
    iguais, a última chave inserida substituirá a primeira.
    Isso pode levar a resultados inesperados e bugs difíceis de rastrear se as chaves
    não forem exclusivas. Se a sua aplicação precisar permitir chaves duplicadas, você
    deve usar outra implementação do Map, como o MultiMap da biblioteca Apache Commons.

---> Pontos importantes e atenções a se tomar:

    1o - Performance: Eficiente em termos de desempenho, pois a pesquisa de elementos
    é feita em tempo constante, em O(1). O desempenho pode diminuir se o fator de carga
    for muito alto. É importante ajustar o tamanho do HashMap adequadamente para otimizar
    o desempenho.

    2o - Chaves únicas: As chaves em um HashMap devem ser únicas. Se uma chave já existir
    no mapa e uma nova entrada com a mesma chave for adicionada, o valor associado à chave
    será substituído pelo novo valor.

    3o - Hashing: Usa o conceito de hashing para armazenar e pesquisar elementos.
    Isso significa que as chaves são mapeadas para índices de tabela usando uma
    função hash. Portanto, é importante que a classe da chave implemente os métodos
    equals() e hashCode() corretamente para garantir que as chaves sejam armazenadas
    e pesquisadas corretamente.

    4o - Nulls: Permite que a chave e o valor sejam nulls. No entanto, se você tentar
    obter o valor associado a uma chave que não existe, o HashMap retornará null.
    É importante verificar se o valor retornado é null ou se a chave existe no mapa.

    5o - Iteração: Fornece várias maneiras de iterar sobre seus elementos, como keySet(),
    values(), entrySet(). É importante escolher a melhor opção de iteração com base na
    sua necessidade.

    6o - Concurrence: Não é thread-safe. Se você precisar usá-lo em um ambiente multithread,
    deve usar a classe ConcurrentHashMap em vez disso.

    7o - Capacidade: Ao criar um HashMap, você pode especificar a capacidade inicial e o fator
    de carga. É importante escolher esses valores com base no tamanho esperado do mapa e no
    desempenho desejado.

    8o - Order: Não garante a ordem dos elementos, pois depende da função hash usada. Se você
    precisar manter a ordem de inserção dos elementos, pode usar a classe LinkedHashMap.

    9o - Evitar Boxing/Unboxing: Para obter um melhor desempenho, evite usar tipos primitivos
    como chaves em um HashMap. Isso requer boxing e unboxing, que pode ser um processo lento
    e desperdiçar recursos. Em vez disso, use as classes correspondentes de objetos, como
    Integer ou Double.

    10o - Clonagem: Pode ser clonado usando o método clone(). No entanto, o clone resultante será
    um novo HashMap que compartilha as mesmas referências dos objetos de chave e valor com o
    original. Se você precisar fazer uma cópia profunda (cópia de objetos aninhados), pode usar
    a classe DeepCloneableHashMap em vez disso.

    11o - Comparação de HashMaps: Para comparar dois HashMaps, você pode usar o método equals().
    No entanto, isso compara apenas os elementos dentro dos HashMaps e não leva em consideração
    a ordem dos elementos ou a referência do objeto do mapa.

    12o - Carga inicial: Ao criar um HashMap, é possível especificar um mapa inicial para preencher
    o mapa com elementos.
    Isso pode ser útil para economizar tempo e desempenho, em vez de adicionar os elementos
    individualmente.

    13o - Substituição de valores: Se você quiser substituir o valor associado a uma chave em um
    HashMap, pode usar o método put() novamente com a mesma chave.
    Isso substituirá o valor antigo pelo novo valor. No entanto, é importante observar que a
    chave deve existir no mapa antes que o novo valor possa ser substituído.

    14o - Java 8 e posterior: A partir do Java 8, o HashMap é compatível com as interfaces Stream
    API e forEach.
    Isso torna mais fácil e conveniente iterar sobre os elementos do mapa usando expressões
    lambda.

    15o - Evitar expansão: Para evitar a expansão frequente do HashMap, que pode ser lenta
    e consumir recursos, é importante definir o fator de carga para um valor adequado ao
    criar o mapa. Um valor comum é 0,75, que oferece um bom equilíbrio entre desempenho e
    uso de memória.

-------------------------------------------------------------------------------
* Class LinkedHashMap: Mantém a ordem de inserção dos elementos e permite acessá-los
através de uma chave. Ela é similar a classe HashMap, com a diferença de que a
LinkedHashMap mantém a ordem de inserção dos elementos, enquanto a HashMap não
garante a ordem de iteração.

A classe LinkedHashMap é útil em situações em que é importante manter a ordem de
inserção dos elementos, por exemplo, em um cache de objetos, em que os objetos mais
recentemente usados devem ser mantidos na frente da lista. Ela também é útil em
algoritmos de busca ou ordenação que precisam acessar os elementos na ordem em que
foram inseridos.

Além disso, a LinkedHashMap oferece algumas opções adicionais de construtor que
permitem criar instâncias da classe com ordem de iteração baseada em ordem de
acesso (através do parâmetro accessOrder) ou em ordem de inserção e limitar o
número de elementos mantidos na coleção (através do parâmetro initialCapacity).

Em resumo, a classe LinkedHashMap é uma implementação de mapas que permite manter
a ordem de inserção dos elementos, o que pode ser útil em diversas aplicações,
especialmente em casos em que é necessário manter uma ordem específica ou acessar
os elementos na ordem em que foram inseridos.

- Algumas das aplicações do LinkedHashMap incluem:

    - Cache: Pode ser usada para implementar um cache, em que os objetos mais
    recentemente usados são mantidos na frente da lista. Como a ordem de inserção
    dos elementos é mantida, é possível remover facilmente os elementos mais antigos
    do cache.

    - Algoritmos de busca e ordenação: Algoritmos de busca e ordenação podem se
    beneficiar do uso da classe LinkedHashMap, especialmente quando a ordem de
    inserção é importante. Por exemplo, um algoritmo de busca pode percorrer os
    elementos em ordem de inserção, o que pode levar a uma melhor performance em
    alguns casos.

    - Manipulação de dados em bancos de dados: Em algumas situações, pode ser útil
    armazenar dados em um LinkedHashMap para manter a ordem de inserção dos registros
    e facilitar a manipulação dos dados em um banco de dados.

Em geral, a classe LinkedHashMap é uma opção útil quando a ordem de inserção dos
elementos é importante e pode ser aplicada em diversas situações em que é necessário
manter uma ordem específica ou acessar os elementos na ordem em que foram inseridos.

- Vantagens:

    - Mantém a ordem de inserção: A principal vantagem é que ela mantém a ordem de
    inserção dos elementos.
    Isso é útil em situações em que é importante manter uma ordem específica, como
    em caches ou algoritmos de busca.

    - Acesso rápido aos elementos: É implementada como uma tabela de hash, o que
    significa que o acesso aos elementos é rápido O(1).

    - Flexibilidade: Oferece opções adicionais de construtor para controlar a ordem
    de iteração e limitar o número de elementos mantidos na coleção.

    - Iteração ordenada por acesso: Além de permitir iterar pelos elementos em ordem
    de inserção também é possível iterar em ordem de acesso (através do parâmetro
    accessOrder no construtor), o que pode ser útil em diversas situações.

    - Remoção fácil de elementos antigos: Como a ordem de inserção é mantida, permite
    remover facilmente os elementos mais antigos da coleção, o que é útil em caches e
    outras situações em que é necessário limitar o número de elementos.

    - Flexibilidade de ordenação: Oferece diversas opções de ordenação, permitindo que
    os elementos sejam organizados de acordo com a necessidade do desenvolvedor.

- Desvantagens:

    - Consumo de memória: Usa mais memória do que outras implementações de Map,
    como HashMap e TreeMap.
    Isso ocorre porque ela precisa manter a ordem de inserção dos elementos, o que
    requer espaço adicional na memória.

    - Performance: Embora o acesso aos elementos seja rápido, a performance pode
    ser afetada pelo tamanho da coleção e pelo número de elementos que precisam ser
    percorridos.
    Isso pode levar a uma performance inferior em comparação com outras implementações
    de Map, especialmente em coleções grandes.

    - Complexidade: É mais complexa do que outras implementações de Map, o que pode
    tornar sua utilização mais difícil em alguns casos.

    - Reordenação custosa: Se a ordem de iteração for baseada em acesso (através do
    parâmetro accessOrder no construtor), a classe pode precisar reordenar os elementos
    internamente, o que pode ter um custo computacional adicional.

    - Performance em grandes coleções: A performance pode ser afetada negativamente em
    coleções muito grandes, especialmente quando a ordem de inserção é importante.

---> Pontos importantes e atenções a se tomar:

    1o - Ordem de inserção: A ordem de inserção dos elementos é mantida, o que pode ser útil
    em diversas situações. É importante lembrar que essa ordem pode ser afetada por
    operações de adição ou remoção de elementos.

    2o - Iteração dos elementos: A iteração dos elementos é realizada na ordem de inserção,
    o que pode ser útil em diversas situações. É importante lembrar que a iteração pode
    ser afetada por operações de adição ou remoção de elementos.

    3o - Performance: A performance pode ser afetada negativamente em coleções muito grandes,
    especialmente quando a ordem de inserção é importante. É importante considerar
    cuidadosamente o tamanho da coleção e as necessidades de performance do sistema
    antes de escolher utilizar essa classe.

    4o - Implementação de interfaces: A classe implementa as interfaces Map e Iterable, o que
    permite que ela seja utilizada em conjunto com outras classes e interfaces do Java.

    5o - Sub-classes personalizadas: A classe pode ser facilmente estendida para criar
    sub-classes personalizadas que adicionam comportamentos específicos, como
    validação de dados, tratamento de exceções, entre outros.

    6o - Uso de memória: A classe pode ocupar mais memória do que outras implementações de
    Map em algumas situações, especialmente quando a ordem de inserção é importante.
    É importante considerar cuidadosamente o uso de memória do sistema e otimizar a
    implementação de acordo.

    7o - Conflitos de hash: Assim como outras implementações de Map baseadas em tabelas de
    hash, a classe LinkedHashMap pode sofrer de conflitos de hash, o que pode levar a
    uma performance inferior em alguns casos.

    8o - Requisitos de sincronização: Se a classe for utilizada em um ambiente multi-threaded,
    podem ser necessárias medidas de sincronização adicionais para garantir a integridade
    dos dados.

    9o - Comparações de igualdade: A classe utiliza o método equals() para comparar a igualdade
    dos elementos, o que pode ser afetado pela implementação específica do método para
    cada elemento. É importante considerar cuidadosamente a implementação desse método
    para evitar problemas de comparação.

    10o - Sobrescrita de chaves: Quando uma chave é adicionada a uma LinkedHashMap já existente,
    ela Sobrescreve a entrada anterior com a mesma chave. É importante lembrar que a ordem
    de inserção da entrada substituída não é afetada.

    11o - Acesso por índice: A classe não permite o acesso por índice direto, o que pode ser um
    problema em algumas situações em que essa funcionalidade é necessária. No entanto, é possível
    utilizar a iteração dos elementos em conjunto com uma variável de controle para obter um acesso
    semelhante.

    12o - Operações de remoção: As operações de remoção em uma LinkedHashMap podem afetar a ordem
    de inserção dos elementos subsequentes. É importante considerar cuidadosamente o impacto
    dessas operações na ordem dos elementos antes de utilizá-las.

    13o - Uso em coleções imutáveis: A classe LinkedHashMap não é uma opção adequada para uso em
    coleções imutáveis, pois a ordem de inserção pode ser afetada por operações de adição ou
    remoção de elementos.

    14o - Carga do fator: A carga do fator é um parâmetro que afeta a eficiência da classe.
    É importante escolher um valor adequado para a carga do fator, que pode variar de acordo
    com o tamanho da coleção e as necessidades de performance do sistema.

    15o - Colisões de hash: A classe pode sofrer de colisões de hash, que podem afetar a
    performance e a eficiência da classe. É importante considerar cuidadosamente a
    qualidade da função hash utilizada para evitar colisões de hash.

    16o - Uso em threads: A classe não é thread-safe, o que significa que não é adequada
    para uso em ambientes multi-threaded sem medidas de sincronização adequadas. É importante
    considerar cuidadosamente o uso da classe em um ambiente multi-threaded e implementar
    as medidas de sincronização necessárias para garantir a integridade dos dados.

    17o - Garbage collection: A classe pode afetar o processo de garbage collection do sistema,
    especialmente quando a coleção é muito grande. É importante considerar cuidadosamente o
    impacto da classe no processo de garbage collection e otimizar a implementação de acordo.

    18o - Iteração reversa: A classe não suporta a iteração reversa dos elementos de forma
    direta. No entanto, é possível utilizar uma iteração dos elementos em conjunto com uma
    pilha ou uma lista para obter um acesso reverso semelhante.

-------------------------------------------------------------------------------