-- Data - (Estudos feitos em Java e agora documentado)
-- link: -
-- Mais informações sobre serialização: -

Intermediário: Mais específico no Java


/* Fluxograma Collections Framework Hierarchy in Java:
                     +----+----+
                    | Collection|                                     +---->   Map  <---+ Interface separada da hierarquia
                     +----+----+                                      |                 |
                          |                                 +---------+---------+-------+-------+
             +------------+-----------+                     |                   |               |
             |                        |                   HashMap          LinkedHashMap     TreeMap
           Set                      List                    |                   |               |
             |                        |                   Hashtable        IdentityHashMap   WeakHashMap
    +--------+-------+       +--------+-------+              |                                  |
    |                |       |                |           Properties                         SortedMap
 HashSet     SortedSet     ArrayList       LinkedList
    |                |            |          /      \
 LinkedHashSet  NavigableSet   Vector  DoublyLinkedList
                                             |
                                          Stack
                                             |
                                       PriorityQueue
 */

---> Tabela de calculos Big-O para as coleções do java:
(Com gráficos: https://www.bigocheatsheet.com/)

- List implementations:
                       get   add   contains  next remove(0)  iterator.remove
 ArrayList             O(1)  O(1)  O(n)      O(1) O(n)       O(n)
 LinkedList            O(n)  O(1)  O(n)      O(1) O(1)       O(1)
 CopyOnWrite-ArrayList O(1)  O(n)  O(n)      O(1) O(n)       O(n)
---------------------------------------------------------------------------
 - Set implementations:
                       add       contains  next      notes
 HashSet               O(1)      O(1)      O(h/n)    h is the table capacity
 LinkedHashSet         O(1)      O(1)      O(1)
 CopyOnWriteArraySet   O(n)      O(n)      O(1)
 EnumSet               O(1)      O(1)      O(1)
 TreeSet               O(log n)  O(log n)  O(log n)
 ConcurrentSkipListSet O(log n)  O(log n)  O(1)
---------------------------------------------------------------------------
 - Map implementations:
                       get       containsKey  next      Notes
 HashMap               O(1)      O(1)         O(h/n)    h is the table capacity
 LinkedHashMap         O(1)      O(1)         O(1)
 IdentityHashMap       O(1)      O(1)         O(h/n)    h is the table capacity
 EnumMap               O(1)      O(1)         O(1)
 TreeMap               O(log n)  O(log n)     O(log n)
 ConcurrentHashMap     O(1)      O(1)         O(h/n)    h is the table capacity
 ConcurrentSkipListMap O(log n)  O(log n)     O(1)
---------------------------------------------------------------------------
 - Queue implementations:
                       offer     peek  poll      size
 PriorityQueue         O(log n)  O(1)  O(log n)  O(1)
 ConcurrentLinkedQueue O(1)      O(1)  O(1)      O(n)
 ArrayBlockingQueue    O(1)      O(1)  O(1)      O(1)
 LinkedBlockingQueue   O(1)      O(1)  O(1)      O(1)
 PriorityBlockingQueue O(log n)  O(1)  O(log n)  O(1)
 DelayQueue            O(log n)  O(1)  O(log n)  O(1)
 LinkedList            O(1)      O(1)  O(1)      O(1)
 ArrayDeque            O(1)      O(1)  O(1)      O(1)
 LinkedBlockingDeque   O(1)      O(1)  O(1)      O(1)
 ---------------------------------------------------------------------------

---> Descrições sobre as complexidades:

As notações de complexidade Big-O são usadas para descrever o tempo de
execução ou espaço de memória necessários para um algoritmo à medida
que o tamanho da entrada aumenta. Essas notações são escritas usando
a notação O() e indicam a ordem de crescimento do algoritmo à medida
que o tamanho da entrada aumenta. Aqui estão as principais notações
de complexidade Big-O e seus significados:

    - O(1): Tempo de execução constante. Isso significa que o algoritmo
    leva a mesma quantidade de tempo, independentemente do tamanho da
    entrada.
    * Exemplo: acesso a um elemento em uma matriz.

    - O(log n): Tempo de execução logarítmico. Isso significa que o tempo
    de execução cresce proporcionalmente ao logaritmo do tamanho da entrada.
    * Exemplo: busca binária em uma lista ordenada.

    - O(n): Tempo de execução linear. Isso significa que o tempo de execução
    cresce proporcionalmente ao tamanho da entrada.
    * Exemplo: percorrer todos os elementos de uma lista.

    - O(n log n): Tempo de execução quase-linear. Isso significa que o tempo
    de execução cresce proporcionalmente ao tamanho da entrada multiplicado
    pelo logaritmo do tamanho da entrada.
    * Exemplo: algoritmos de classificação eficientes, como o mergesort ou o
    heapsort.

    - O(n^2): Tempo de execução quadrático. Isso significa que o tempo de
    execução cresce proporcionalmente ao quadrado do tamanho da entrada.
    * Exemplo: algoritmos de ordenação com desempenho inferior, como
    bubble sort ou selection sort.

    - O(2^n): Tempo de execução exponencial. Isso significa que o tempo de
    execução cresce exponencialmente em relação ao tamanho da entrada.
    * Exemplo: algoritmos de força bruta, como a resolução do problema do
    caixeiro-viajante.

    - O(n!): Tempo de execução fatorial. Isso significa que o tempo de execução
    cresce fatorialmente em relação ao tamanho da entrada.
    * Exemplo: resolução do problema de permutação.

    Geralmente, um algoritmo com complexidade Big-O menor é preferível, pois
    requer menos recursos computacionais à medida que o tamanho da entrada
    aumenta. No entanto, em muitos casos, é necessário comprometer entre a
    eficiência do algoritmo e a simplicidade de implementação ou outros
    requisitos do sistema.

-------------------------------------------------------------------------------

---> Classes/métodos aboradados neste package:

* Métodos equals() e hashCode(): Sempre garantir implementação linear delas.
    - Garantir que ambas estejam coerentes entre sí.
    - Essencial para se trabalhar com coleções.

* Interface List<E>: Interface mais básica no contexto de coleções, implementações:
    * Class ArrayList<E>: Classe mais básica que utiliza Array nativo em LowLevel.
    * Class LinkedList<E>: Não é para estar aqui na ordem de documentação pois é
    necessário estudos sobre os pontos destacados abaixo, porisso ela também
    está descrita abaixo, para não perder a ordem cronológica necessária para
    melhor entendimento.

* Util Class Collections: Classe 100% Utilitária, para trabalhar com Coleções.

* Operações importantes:
    - Sorting Lists: Organizando coleções em ordem ASC ou DESC. (Comparable/Comparator).
    - BinarySearch: Busca binária, utilizada em coleções ordenadas ASC ou DESC.

    - List to Array convertion: Convertendo List<E> em Array e vici versa.

* Interface Iterator<E>: Toda coleção até mesmo Array Nativo utiliza em LowLevel (for).
    - Interessante para realizar verificações antes de modificar uma coleção.
    - Evita `CurrentModificationException` por conta do ponto a cima.
    - Em casos de remove() utilizar programação funcional com removeIf().

* Class LinkedList<E>: Implementação de List não utiliza Array nativo em LowLevel.
    - Diferentemente de ArrayList que utiliza o Array nativo do java em Lowlevel,
    ela utiliza o conceito de "lista encadeada" e tem seu tamanho dinâmico sem
    precisar re-criar arrays e alterar o ponteiro da variável de referência.
    - Melhor implementação de List<E> para remoção de elementos. (Big-O).

* Interface Set<E>: Interface que serve para representar um conjunto de elementos
únicos e não ordenados.
    - Com métodos uteis para operações de conjuntos (união, interseçãoe e diferença).
    - Verificação de cardinalidade.
    - Mais performance em alguns casos.

    * Class HashSet<E>:
        - Implementação baseada em tabela hash;
        - Não mantém a ordem de inserção dos elementos;
        - É a mais rápida em termos de operações de adição, remoção e busca;
        - É adequada para casos em que a ordem dos elementos não importa e a
        velocidade é uma prioridade.

    * Class LinkedHashSet<E>:
        - Implementação baseada em tabela hash com lista duplamente ligada para
        manter a ordem de inserção;
        - Mantém a ordem de inserção dos elementos;
        - É um pouco mais lenta do que o HashSet, mas ainda é rápida;
        - É adequada para casos em que a ordem dos elementos importa
        e a velocidade é uma prioridade moderada.

    * TreeSet<E>:
        - Implementação baseada em árvore binária balanceada (Red-Black Tree);
        - Mantém os elementos em ordem crescente;
        - É mais lenta do que o HashSet e o LinkedHashSet, mas ainda é rápida;
        - É adequada para casos em que os elementos precisam ser mantidos em ordem crescente.

    * EnumSet<E>:
        - Implementação especializada para conjuntos de elementos enum;
        - Usa um vetor de bits para representar os elementos do conjunto;
        - É extremamente rápida e eficiente em termos de espaço;
        - É adequada para casos em que os elementos do conjunto são do tipo enum.

    * CopyOnWriteArraySet<E>:
        - Implementação baseada em um array que é copiado sempre que o conjunto é modificado;
        - Mantém os elementos em ordem de inserção;
        - É mais lenta do que as outras implementações do Set;
        - É adequada para casos em que a leitura do conjunto é muito mais frequente do que a modificação e a concorrência é um problema.

-------------------------------------------------------------------------------

---> Definições mais a fundo sobre cada um dos tópicos:

* equals() e hashCode():
- Utilizado para comparar Objetos, ambos devem ser concistentes entre sí.
- Equals e HashCode são muito utilzados em Listas complexas e com maior
  performance, como HashSet e HashMap. Pois ao invés de comparar elemento
  a elemento da lista, eles utilizam o hashCode como index, assim podemos
  acessar o Objeto da lista diretamente sem precisar realizar a iteração
  elemento a elemento como algoritmos mais simples fazem.

- Atenções sobre:
    CUIDADOS ao trabalhar com Objetos mutáveis e hashCode pois o hash muda,
    e assim pode gerar possíveis inconcistências ao utilizar métodos de
    busca e etc!
    - Sempre utilizar atributos constantes para gerar os hashs e garantir
    imutabilidade.

- Regras para a implementação do equals em um Object Model:

  - Reflexivo: x.equals(x) == true para tudo != null;
  - Simétrico: para x e y != null, se x.equals(y) == true logo y.equals(x)
  também tem que ser true.
  - Transitividade: para x, y e z != null,
  se x.equals(y) && x.equals(z) == true então y.equals(z) tambeḿ tem que
  ser true.
  - Consistente: para todas as chamadas, x.equals(x) sempre retorna true
  desde que x != null.
  para x != null, x.equals(null) tem que retorna false;

-------------------------------------------------------------------------------
* Interface List<E>:É uma das interfaces mais importantes do framework de
coleções do Java. Ela define um contrato para classes que representam
sequências ordenadas de elementos e oferece uma série de métodos para
manipulação dessas sequências, permitindo a adição, remoção e acesso
aos elementos por índice.
- Interface mais genérica utilizada neste contexto.
- Programação Orientada a Interface: As coleções no java são bem coesas
e essa abordagem é bastante utilizada pois ajuda na manutenção do cod.





-------------------------------------------------------------------------------
* ArrayList<E>: É uma implementação da interface List que usa uma matriz
interna para armazenar seus elementos. Ao adicionar um elemento a uma
ArrayList, a matriz interna pode precisar ser redimensionada, o que
pode ser um processo lento se a lista for grande. Portanto, se você
precisa adicionar muitos elementos a uma ArrayList, considere usar um
LinkedList em vez disso.

- O método add() da ArrayList<T> adiciona um elemento ao final da lista.
Se você precisar adicionar um elemento em uma posição específica, use o
método add(int index, T element) em vez disso. No entanto, tenha cuidado
ao adicionar elementos em posições intermediárias, pois isso pode exigir
que todos os elementos subsequentes sejam movidos para cima na matriz
interna.

- A ArrayList<T> é uma estrutura de dados mutável, o que significa que os
elementos podem ser alterados a qualquer momento. Isso pode ser útil em
alguns casos, mas também pode tornar seu código mais difícil de entender
e depurar. Considere usar coleções imutáveis, como a List<T> fornecida
pela classe Collections, sempre que possível.

- A ArrayList<T> não é sincronizada, o que significa que não é segura para
uso em threads concorrentes. Se você precisar compartilhar uma lista entre
várias threads, considere usar uma lista sincronizada ou um
CopyOnWriteArrayList<T> em vez disso.

- A ArrayList<T> implementa a interface Serializable, o que significa que
pode ser serializada e desserializada facilmente. Isso pode ser útil ao
salvar e carregar listas em um arquivo ou enviar listas pela rede.

-------------------------------------------------------------------------------
* SortingLists:
- Ordenando listas com o método Collections.sort(): método sobrecarregado,
podemos passar apenas a coleção que será ordenada, ou também acrescentar
um obj que implemente Comparator<T> no segundo parâmetro.

- Para ordenar a coleção, o obj em ordenação desta lista precisa implementar
Comparable<T> ou então será necessário criar uma instância Comparator<T> e
nele definir a regra de ordenação para o método compare().
(Oque torna um obj maior>, menor< ou igual== a outro?).
    - Obs: Mesma regra definida em um obj que implements Comparable<T>.

- Quando utilizar Comparable<T> ou Comparator<T> ?
    Implementamos o Comparable<T> num objeto quando queremos definir uma
    regra "Geral/Natural" de ordenação, essa seria a regra "default" de
    ordenação, ou seja, válida para o programa como um "tôdo" pois toda
    vez que o Java precisar comparar dois objetos, ele utilizará essa
    regra como critério, "chamando" o método compareTo(Object otherObj);

    - Implementamos o Compartor<T> quando queremos alterar por algum
    motivo essa regra inicial apenas em pontos específicos no programa,
    alterando assim essa ordenação "Natural/Default" do Objeto em
    questão.
        - Também podemos utilizar essa abordagem quando o objeto em
        ordenação não estiver sob nosso controle, por algum motivo
        como API's de terceiros ou classes que não conhecemos bem
        o seu comportamento/uso geral no programa, então para isso
        criamos ou implementamos um Comparator<T> e definimos a
        regra, sem afetar a Classe do Objeto em ordenação em sí.

    - Dica: Caso queira utilizar como critério de comparação Objetos
    internos a outros em aninhamento como por exemplo ordenar uma
    lista de pedidos com base no nome dos clientes, ou ir além, basta
    na implementação do Comparator<T> utilizar o get multiplas vezes
    até encontrar o Objeto do nível correto:

      @Override
      public int compare(Pedido p1, Pedido p2) {
          String nomeCliente1 = p1.getCliente().getNome(); // -> Aqui poderia ter get().get().get()...
          String nomeCliente2 = p2.getCliente().getNome(); // Até chegar no nível do Objeto desejado.
          return nomeCliente1.compareTo(nomeCliente2);
      }

- Além dessa implementação necessária para a ordenação de elementos,
também é necessário a implementação correta do equals() e hashCode().

- Collections: Classe 100% estática utilizada como Utilitário no contexto
de coleções no Java.

-------------------------------------------------------------------------------
* BinarySearch: Método utilitário do Collections.
- É um dos métodos estáticos do Collections.binarySearch(numbersList, 6);
Aonde ´numberList´ é a coleção e ´6´ é o index do elemento em search.
- Podemos também aplicar esse método em Arrays nativos do Java,
  porém o mesmo deve garantir a ordenação dos elementos.
- Para utilizar é necessário passar uma coleção ordenada (sort()),
pois ele utiliza tecnicas de programação que otimizam a performance.

- REGRA: O retorno será o index do elemento, com algumas convenções sendo
 elas:
    - A Diferença dele para um indexOf() é que além de retornar NEGATIVO
    quando um Objeto não existe na lista retorna também em qual posição
    o elemento deveria estar para manter a lista ordenada.

    - Quando EXISTE o elemento em busca, retorna um inteiro POSITIVO que
    representa o index dele.

    - Quando NÃO existe o elemento em busca, retorna um inteiro NEGATIVO
    que representa o index em que o elemento deve ser inserido para manter
    a lista ordenada subtraindo 1. (-(ponto de inserção) -1)
    Aonde "ponto de inserção" == index aonde o elemento deveria estar para
    manter a lista ordenada.
        - Subtraí 1 pois se o valor retornado fosse 0 não saberiamos se é
        o resultado Exists do elemento, ou se é a posição em que o elemento
        deveria estar, ou seja NotExists.
            - OU SEJA, ele garante que só irá retornar POSITIVO se o elemento
            Exists, caso contrario o retorno será sempre NEGATIVO.

            - PORISSO deve se ATENTAR ao criar coleções com valores NEGATIVOS,
            pois ai iria adicionar mais complexidade nesta lógica,
            e a matematica que deverá ser aplicada após o processamento,
            fazendo assim com que a transformação correta do elemento teria
            que levar em consideração esse fator.

        - FÓRMULA em casos de retorno NEGATIVO indicando que o elemento não
        exists na lista, sendo necessário assim transformar o index
        corretamente para obter o index real no qual o elemento deveria estar
        para manter a lista organizada/sorted:

              int realIndex = 0;
              if (indexOfElementWithBinarySearched < 0){
                  realIndex = -(indexOfElementWithBinarySearched + 1);

                  ... Aqui podemos realizar a criação e inserção do Objeto na lista,
                  de uma forma em que mantém a lista organizada na regra definida em Comparable<T>

              } else { // POSITIVO não é preciso, pois o index vem corretamente.
                  realIndex = indexOfElementWithBinarySearched;
              }

- Vantagens de se utilizar a busca binária: APENAS e só APENAS se aplica em
listas Sorted/Ordenadas!!

     - A vantagem de utilizar o método binarySearch() é a eficiência em
     encontrar um elemento de uma lista ordenada. A busca binária é um
     algoritmo eficiente para encontrar um elemento de uma lista ordenada,
     pois a busca é feita pela metade da lista em cada iteração, reduzindo
     drasticamente o número de comparações necessárias.

     - Em comparação com uma busca linear, em que cada elemento da lista é
     verificado um por um até que o elemento procurado seja encontrado, a
     busca binária é significativamente mais rápida para listas maiores.
     Isso se deve ao fato de que a BUSCA BINÁRIA corta a lista pela METADE
     a cada iteração, enquanto a busca LINEAR percorre TODOS os elementos
     da lista.

- Desvantagens de se utilizar a busca binária:

    - A lista deve estar ordenada: A busca binária requer que a lista esteja
    ordenada em ordem crescente ou decrescente antes de executar a busca.
    Isso significa que, se a lista não estiver ordenada corretamente, será
    necessário ordená-la antes de realizar a busca, o que pode ser um
    processo custoso em termos de tempo.

    - Não é adequado para listas pequenas: A busca binária é mais eficiente
    para listas grandes, pois seu desempenho aumenta exponencialmente à
    medida que o tamanho da lista aumenta. Para listas pequenas, o desempenho
    da busca binária pode ser comparável ou até mesmo pior do que outras
    técnicas de busca, como a busca linear.

    - Não é adequado para listas mutáveis: A busca binária é projetada para
    ser usada com listas imutáveis, ou seja, listas que não mudam durante a
    busca. Se a lista estiver sendo modificada enquanto a busca estiver em
    andamento, pode haver problemas com a ordem dos elementos e o resultado
    da busca pode ser impreciso.

    - Não é adequado para tipos de dados complexos: A busca binária é melhor
    usada com tipos de dados simples, como inteiros ou caracteres. Para tipos
    de dados complexos, como objetos personalizados, pode ser necessário
    definir uma ordem de classificação personalizada ou sobrescrever o método
    compareTo() para que a busca binária funcione corretamente.

    - Requer que a lista implemente a interface List: O método binarySearch()
    do Collections só pode ser usado em listas que implementam a interface
    List. Se você estiver usando uma lista que não implementa a interface
    List, será necessário usar uma implementação personalizada da busca binária.

    - Pode retornar resultados imprecisos ou inesperados: Em alguns casos, o
    método binarySearch() pode retornar resultados imprecisos ou inesperados,
    especialmente se a lista contiver elementos duplicados. Nesses casos, o
    método pode retornar qualquer índice correspondente a um elemento
    encontrado, mas não necessariamente o índice do elemento desejado.

    - Não é adequado para buscas por critérios complexos: A busca binária é
    adequada para encontrar elementos por valor exato. No entanto, se você
    precisar procurar por elementos com base em critérios mais complexos,
    como faixa de valores ou correspondência parcial de strings, a busca
    binária pode não ser a melhor opção.

    - A complexidade da implementação: Implementar a busca binária requer
    conhecimento prévio e pode ser um processo complexo, especialmente se
    você estiver lidando com casos não triviais, como a busca em listas
    multidimensionais.

    - Pode ser menos eficiente em cenários de memória limitada: A busca
    binária requer que a lista esteja ordenada em memória antes de executar
    a busca, o que pode ser um problema em cenários com limitações de memória.
    Em tais cenários, outras técnicas de busca, como a busca linear ou a busca
    hash, podem ser mais eficientes.

-------------------------------------------------------------------------------
* List to Array Convertion: Conversões Array nativo <=> List e vici versa.

- Transformando uma List<E> em um Array:
    Object[] objects = inteiros.toArray(); -> sem especificar ele retorna Objects
    Integer[] listToArray = integersList.toArray(new Integer[0]);

- Transformando um Array em uma List<E>:
    List<Integer> integers = Arrays.asList(listToArray); // linka os dois arrays em uma List<T>
    //integers.add(4); -> Operação inválida pois Arrays não podem ser redimensionados.
    integers.set(2, 4); // Operação VÀLIDA pois não estemos alterando o dimensionamento do array (size)

    List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray)); // SOLUÇÃO: quebra o link

- Arrays.asList():
    - É otimizado para criar uma lista de tamanho fixo a partir de um array
     existente e, portanto, é mais eficiente em termos de memória e
     desempenho. Além disso, o método retorna uma visualização da lista,
     o que significa que não é criada uma nova instância de lista. Em vez
     disso, é criado um objeto interno que atua como uma "janela" para o
     array subjacente, permitindo que você trabalhe com a lista como se
     fosse uma lista regular.

         - SOLUÇÃO: Para quebrar esse vínculo utilizar o array no construtor
         e criar uma nova instância de List<T>:
         List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray));

-------------------------------------------------------------------------------
* Iterator: Classe utilizada para percorrer listas, neste contexto ela é util
em casos aonde é preciso realizar alguma verificação antes de tomar alguma
ação sobre cada elemento da lista, por exemplo quando se quer remover um
elemento de uma forma segura (safe delete) evitando assim Exceptions como a
´CurrentModificationException´, pois não é recomendável realizar mudanças
correntes em coleções que estão sendo percorridas (looping).

- Com Iterator que checa antes de executar uma ação (SEM programação funcional):

        Iterator<PatientModel> patientIterator = patientModelList.iterator();
        while (patientIterator.hasNext()) {
            PatientModel patient = patientIterator.next();
            if(patient.getPriority() == 0){
                patientIterator.remove();
            }
        }

- Alternativa recomendável SEM Iterator, utilizando programação funcional:

    patientModelList.removeIf(patient -> patient.getPriority() == 0);

- Em Java, um Iterator é uma interface que permite percorrer coleções de elementos,
como List, Set e Map. Ele fornece um conjunto de métodos para acessar e percorrer
os elementos de uma coleção, sem expor a estrutura interna da coleção.

  - A interface Iterator define três métodos principais:

      hasNext(): retorna true se a coleção contém mais elementos a serem iterados.
      next(): retorna o próximo elemento na coleção.
      remove(): remove o elemento atual da coleção.

- O Iterator é útil em situações em que você precisa percorrer uma coleção de
elementos, mas não sabe quantos elementos ela contém ou não quer expor a
estrutura interna da coleção. Por exemplo, se você estiver trabalhando com uma
List grande e quiser iterar apenas sobre alguns elementos específicos, pode
usar um Iterator em vez de percorrer a lista inteira.

- Outra utilidade do Iterator é permitir a remoção segura de elementos de uma
coleção enquanto a iteração está em andamento. Ao usar o método remove() do
Iterator, você pode remover o elemento atual da coleção sem causar problemas
de concorrência ou exceções do tipo ´ConcurrentModificationException´.

---> Pontos a se considerar quando se utiliza:

    1o - Use o for-each loop sempre que possível: o for-each loop é uma forma
    mais simples e segura de iterar sobre uma coleção em Java. Ele utiliza um
    Iterator por baixo dos panos e garante que a iteração será feita
    corretamente, sem precisar se preocupar com os detalhes do Iterator
    manualmente.

    2o - Use o try-with-resources para garantir a liberação dos recursos: quando
    se trabalha com um Iterator, é importante garantir que ele seja liberado
    corretamente após o uso para evitar possíveis vazamentos de recursos.
    O try-with-resources é uma forma conveniente de garantir que o Iterator seja
    fechado automaticamente ao final do bloco de código.

    3o - Prefira usar o `ListIterator` para iterações bidirecionais: se você
    precisar iterar sobre uma lista em ambas as direções (para frente e para
    trás), é recomendável usar o `ListIterator` em vez do `Iterator.
    O `ListIterator` suporta iterações bidirecionais e oferece mais recursos,
    como a possibilidade de adicionar ou remover elementos durante a iteração.

    4o - Use o `Spliterator` para iterações em paralelo: se você precisar iterar
    sobre uma coleção em paralelo (em várias threads), é recomendável usar o
    Spliterator. O Spliterator é projetado para suportar iterações em paralelo
    de forma segura e eficiente, sem precisar se preocupar com problemas de
    concorrência.

    5o - Use o método forEachRemaining() para iterações restantes: o método
    forEachRemaining() é um método do Iterator que itera sobre os elementos
    restantes na coleção e executa uma ação especificada. Ele é útil quando
    você precisa executar uma ação em todos os elementos da coleção, mesmo
    que a iteração tenha sido interrompida prematuramente. Por exemplo, você
    pode usar o forEachRemaining() para limpar uma coleção depois que ela foi
    parcialmente iterada.

    6o - Considere usar a classe Iterable para criar suas próprias coleções
    iteráveis: se você estiver criando suas próprias coleções personalizadas,
    é recomendável implementar a interface Iterable para permitir que elas
    sejam iteradas facilmente usando um for-each loop ou um Iterator.
    A interface Iterable exige a implementação do método iterator(), que deve
    retornar um objeto Iterator para a coleção.
        - Para listas personalizadas que seram utilizadas paralelamente,
        deve-se implementar a interface Spliterator.

    7o - Use o Enumeration para iteração em coleções legadas: se você estiver
    trabalhando com coleções legadas (anteriores ao Java 2) que não implementam
    a interface Iterable, pode usar a classe Enumeration para iterar sobre os
    elementos. A classe Enumeration oferece métodos semelhantes aos do Iterator,
    mas é menos flexível e menos eficiente.

    8o - Considere usar bibliotecas de iteração externas: se você estiver
    trabalhando com coleções complexas ou precisar de funcionalidades avançadas
    de iteração, pode ser útil usar bibliotecas de iteração externas, como o
    Apache Commons Collections ou o Guava. Essas bibliotecas oferecem recursos
    avançados de iteração, como iteração baseada em predicado, iteração reversa,
    iteração filtrada e muito mais.

    9o - Use o StreamSupport para criar um Stream a partir de um Iterator ou
    Spliterator: se você tiver um objeto Iterator ou Spliterator e desejar
    convertê-lo em um Stream, pode usar o método StreamSupport.stream() do
    Java 8. Esse método permite que você crie um Stream a partir de um
    Iterator ou Spliterator personalizado.

    10o - Use o Optional para evitar exceções de iteração: em algumas situações,
    pode ser possível que a coleção esteja vazia ou que não haja mais elementos
    para iterar. Nesses casos, em vez de lançar uma exceção, é recomendável usar
    a classe Optional para lidar com o valor nulo. O método next() do Iterator
    retorna um objeto Optional, permitindo que você verifique se há um próximo
    elemento sem lançar uma exceção.

    11o - Use o método hasNext() com moderação: embora o método hasNext() do
    Iterator seja útil para verificar se há mais elementos na coleção, seu uso
    excessivo pode afetar negativamente o desempenho. Isso ocorre porque o método
    hasNext() geralmente precisa percorrer a coleção para verificar se há mais
    elementos. Em vez de verificar a cada iteração, é recomendável verificar
    apenas quando necessário ou usar o for-each loop para iterar sobre a coleção.

-------------------------------------------------------------------------------
* LinkedList<E>: Listas encadeadas/ligadas
- Melhor Implementação de List para remoção de elementos:
    Complexidade Big-O remove(): O(1);

LinkedList é uma estrutura de dados em Java que é usada para armazenar uma
coleção de elementos, onde cada elemento é chamado de nó e contém um valor
e um ponteiro para o próximo nó na lista. (Estilo "Trem" aonde cada vagão é
um Nó que aponta para o anterior e próximo).

Essa estrutura de dados é útil quando precisamos inserir ou excluir elementos
com frequência, pois ela permite que as operações de inserção e remoção sejam
realizadas com eficiência, sem a necessidade de realocar memória como ocorre
em um array.

Além disso, a LinkedList é uma lista duplamente encadeada, o que significa que
cada nó também possui um ponteiro para o nó anterior na lista, permitindo
percorrer a lista em ambas as direções.

Na prática, as LinkedLists são usadas em diversas aplicações, como em
implementações de filas, pilhas, e listas de reprodução de músicas,
onde é necessário adicionar ou remover elementos com frequência.

- Vantagens:

    - Inserção e remoção eficientes: Uma das principais vantagens das LinkedLists
    é que a inserção e a remoção de elementos podem ser muito eficientes, pois não
    requerem deslocamento de outros elementos como ocorre em arrays.

    - Flexibilidade de tamanho: LinkedLists permitem adicionar ou remover elementos
    dinamicamente, o que significa que você não precisa alocar um tamanho fixo de
    memória, como acontece em arrays.
    Isso pode ser útil quando você não sabe de antemão quantos elementos precisa
    armazenar.

    - Iteração eficiente: Iterar sobre todos os elementos de uma LinkedList pode
    ser muito eficiente, já que cada elemento contém um ponteiro para o próximo
    elemento, o que permite percorrer toda a lista sem a necessidade de cálculo
    de índices.

- Desvantagens:

    - Acesso aleatório ineficiente: Enquanto as LinkedLists são boas para inserir
    e remover elementos, o acesso aleatório a um elemento específico pode ser
    ineficiente, pois não há um índice fixo para cada elemento, exigindo uma
    busca sequencial.

    - Consumo de memória: Cada elemento de uma LinkedList requer uma alocação de
    memória separada, o que pode tornar as LinkedLists menos eficientes em termos
    de memória do que arrays, especialmente para listas de tamanho grande.

    - Dificuldades em ordenação: É mais difícil ordenar elementos em uma LinkedList
    do que em um array, uma vez que os elementos estão distribuídos de forma não
    contígua na memória.
    Isso pode levar a algoritmos de classificação menos eficientes em uma LinkedList.

    - Dificuldade de inversão: Inverter uma LinkedList é uma operação relativamente
    complexa, uma vez que envolve a atualização de ponteiros para cada elemento.
    Isso pode tornar a inversão menos eficiente do que em outras estruturas de dados.

Em geral, as LinkedLists são úteis quando a eficiência de inserção e remoção é uma
prioridade e quando o tamanho da lista pode mudar ao longo do tempo. Por outro lado,
se você precisa de acesso aleatório eficiente a elementos ou se está trabalhando com
listas muito grandes, pode ser melhor escolher uma estrutura de dados diferente, como
um array ou uma árvore.

---> Pontos a se considerar quando se utiliza:

    1o - Inserção e remoção de elementos: como mencionado anteriormente, a
    LinkedList é uma estrutura de dados que permite a inserção e remoção
    eficiente de elementos. Porém, tenha cuidado ao realizar essas
    operações em listas grande, pois elas podem ser computacionalmente
    custosas.

    2o - Acesso aos elementos: a LinkedList não é uma estrutura de dados
    adequada para acesso aleatório aos elementos, ou seja, acessar um
    elemento pelo seu índice.
    Isso porque para acessar um elemento específico, é necessário percorrer
    a lista a partir do início ou do fim, o que pode ser lento em listas
    grandes.

    3o - Uso de iterações: o uso de iterações (loops) em LinkedLists é comum
    para percorrer todos os elementos ou realizar alguma operação em cada
    elemento. No entanto, tenha cuidado ao modificar a lista durante a
    iteração, pois isso pode causar comportamentos inesperados ou mesmo erros.

    4o - Uso do Iterator: para percorrer uma LinkedList de forma segura, é
    recomendado utilizar a classe Iterator do Java, que permite iterar sobre
    os elementos da lista sem causar modificações inesperadas.

    5o - Uso do método equals: a LinkedList implementa o método equals para
    comparar duas listas. No entanto, esse método compara os elementos da
    lista um a um, o que pode ser lento em listas grandes. Portanto, tenha
    cuidado ao usar o método equals em LinkedLists grandes.

    6o - Uso do método clone: a LinkedList também implementa o método clone
    para criar uma cópia da lista. No entanto, essa operação pode ser custosa
    em termos de memória e processamento, especialmente em listas grandes.
    Portanto, tenha cuidado ao usar o método clone em LinkedLists grandes.

    7o - Uso do método toArray: o método toArray da LinkedList permite criar
    um array com os elementos da lista. No entanto, esse método cria uma cópia
    dos elementos da lista, o que pode ser lento em listas grandes. Portanto,
    tenha cuidado ao usar o método toArray em LinkedLists grandes.

    8o - Uso de memória: a LinkedList consome mais memória do que outras
    estruturas de dados, como arrays, devido à necessidade de armazenar
    referências para cada elemento da lista. Portanto, é importante
    considerar a quantidade de memória disponível e o tamanho da
    lista ao escolher a implementação adequada.

    9o - Comportamento de ordenação: a LinkedList não é automaticamente
    ordenada em Java, portanto, se você precisa de uma lista ordenada,
    é necessário implementar a ordenação por conta própria.

-------------------------------------------------------------------------------
Fonte interessanta: https://www.devmedia.com.br/diferencas-entre-treeset-hashset-e-linkedhashset-em-java/29077
* Interface Set<E>: Set é uma interface com o mesmo contexto da List, porém para
trabalhar com HashSet, LinkedHashSet, NavigableSet e TreeSet.

A interface Set é uma das interfaces de coleções do Java e serve para representar
um conjunto de elementos únicos e não ordenados. Os elementos de um Set não são
duplicados e não possuem uma ordem específica.

A interface Set define um conjunto de métodos que permitem a adição, remoção e
verificação de elementos em um conjunto, bem como a verificação de sua
cardinalidade e a realização de operações de conjuntos, como união, interseção
e diferença. Alguns dos principais métodos da interface Set incluem:

    - add(elemento): adiciona um elemento ao conjunto, caso ele ainda não esteja presente;
    - remove(elemento): remove um elemento do conjunto, caso ele esteja presente;
    - contains(elemento): verifica se um elemento está presente no conjunto;
    - size(): retorna o número de elementos do conjunto;
    - isEmpty(): verifica se o conjunto está vazio;
    - clear(): remove todos os elementos do conjunto;
    - iterator(): retorna um objeto Iterator para percorrer os elementos do conjunto.

A interface Set é implementada por diversas classes no Java, incluindo HashSet,
TreeSet e LinkedHashSet. Cada uma dessas classes implementa a interface Set de
forma diferente, com características específicas que podem ser mais adequadas
para diferentes cenários de uso.

Alguns exemplos de uso da interface Set incluem a remoção de elementos duplicados
de uma lista, a verificação de elementos únicos em um conjunto de dados e a
realização de operações de conjuntos, como a interseção de dois conjuntos.
A interface Set é uma ferramenta importante na programação em Java para lidar com
conjuntos de elementos de forma eficiente e elegante.

É importante lembrar que, como um Set não permite elementos duplicados, a classe
dos elementos deve implementar os métodos equals() e hashCode() corretamente para
garantir que os elementos sejam comparados corretamente.

---> Algumas implementações comuns da interface Set no Java incluem:

    * HashSet: implementação baseada em tabela hash que fornece acesso rápido aos
    elementos, mas não mantém a ordem dos elementos.

    * TreeSet: implementação baseada em árvore que mantém os elementos em ordem
    crescente ou decrescente, mas pode ser mais lenta que o HashSet.

    * LinkedHashSet: implementação que mantém a ordem de inserção dos elementos,
    mas pode ser mais lenta que o HashSet.

- Vantagens:

    - Não permitem elementos duplicados, o que pode ajudar a evitar erros em
    operações com conjuntos de dados.

    - Permitem operações de união, interseção e diferença entre conjuntos,
    facilitando a manipulação de dados.

    - Fornecem uma variedade de implementações diferentes que podem ser escolhidas
    com base nas necessidades específicas do problema em questão.

    - Oferecem desempenho rápido para operações de adição, remoção e verificação de
    pertinência de elementos em relação a outras estruturas de dados.

- Desvantagens:

    - Não permitem acesso a elementos com base em sua posição no conjunto, já que
    não mantêm uma ordem específica.

    - Algumas implementações podem ser menos eficientes do que outras para
    determinadas operações, o que pode levar a um desempenho abaixo do esperado.

    - O uso excessivo de conjuntos pode levar a um aumento no uso de memória,
    especialmente se eles contiverem muitos elementos.

    - As classes que implementam a interface Set são mutáveis, o que significa
    que elas podem ser modificadas a qualquer momento, tornando difícil prever
    seu estado atual.

---> Diferenças de uso para cada classe que implementa:

* HashSet:
    - Implementação baseada em tabela hash;
    - Não mantém a ordem de inserção dos elementos;
    - É a mais rápida em termos de operações de adição, remoção e busca de elementos;
    - É adequada para casos em que a ordem dos elementos não importa e a velocidade é uma prioridade.

* LinkedHashSet:
    - Implementação baseada em tabela hash com lista duplamente ligada para manter a ordem de inserção;
    - Mantém a ordem de inserção dos elementos;
    - É um pouco mais lenta do que o HashSet, mas ainda é rápida;
    - É adequada para casos em que a ordem dos elementos importa e a velocidade é uma prioridade moderada.

* TreeSet:
    - Implementação baseada em árvore binária balanceada (Red-Black Tree);
    - Mantém os elementos em ordem crescente;
    - É mais lenta do que o HashSet e o LinkedHashSet, mas ainda é rápida;
    - É adequada para casos em que os elementos precisam ser mantidos em ordem crescente.

* EnumSet:
    - Implementação especializada para conjuntos de elementos enum;
    - Usa um vetor de bits para representar os elementos do conjunto;
    - É extremamente rápida e eficiente em termos de espaço;
    - É adequada para casos em que os elementos do conjunto são do tipo enum.

* CopyOnWriteArraySet:
    - Implementação baseada em um array que é copiado sempre que o conjunto é modificado;
    - Mantém os elementos em ordem de inserção;
    - É mais lenta do que as outras implementações do Set;
    - É adequada para casos em que a leitura do conjunto é muito mais frequente do que a modificação e a concorrência é um problema.

---> Pontos importantes e atenções em comum entre elas:

    1o - Evite a adição de elementos duplicados: como as classes que implementam
    a interface Set não permitem elementos duplicados, é importante garantir que
    os elementos adicionados sejam únicos. Para isso, é possível sobrescrever o
    método equals() do objeto que será adicionado ou implementar a interface
    Comparable para definir uma ordem natural para os elementos.

    2o - Escolha a implementação correta: o Java oferece várias implementações
    diferentes da interface Set, cada uma com suas próprias características e
    desempenho. Por exemplo, a classe HashSet é eficiente para operações de
    adição e busca, mas não mantém uma ordem específica para os elementos.
    Já a classe TreeSet mantém os elementos em ordem natural ou definida por um
    Comparator, mas tem um desempenho um pouco mais lento. É importante escolher
    a implementação correta com base nas necessidades do seu código.

    3o - Fique atento à complexidade de tempo: algumas operações em conjuntos
    podem ter complexidade de tempo alta, especialmente em conjuntos grandes.
    Por exemplo, a operação de união entre dois conjuntos grandes pode ser
    bastante demorada, mesmo em uma implementação eficiente. Portanto, é
    importante estar ciente dessas limitações e considerar alternativas caso
    seja necessário trabalhar com conjuntos muito grandes.

    4o - Use métodos específicos: as classes que implementam a interface Set
    fornecem uma variedade de métodos específicos que podem facilitar a
    manipulação de conjuntos de dados. Por exemplo, o método addAll() permite
    adicionar todos os elementos de uma coleção em um conjunto existente,
    enquanto o método retainAll() permite manter apenas os elementos em comum
    entre dois conjuntos. É importante explorar esses métodos para obter o
    máximo de desempenho e facilidade de uso.

    7o - Considere a sincronização: as classes que implementam a interface Set
    não são thread-safe por padrão, o que significa que não é seguro acessá-las
    de várias threads simultaneamente. Se você precisar trabalhar com conjuntos
    em um ambiente concorrente, é importante sincronizar o acesso ao conjunto
    com as palavras-chave synchronized ou com as classes da biblioteca
    java.util.concurrent.

    8o - Não altere o conjunto enquanto estiver percorrendo seus elementos: se
    você estiver percorrendo um conjunto usando um iterador, é importante não
    alterar o conjunto enquanto estiver percorrendo seus elementos.
    Isso pode levar a resultados inesperados ou erros de tempo de execução.
    Em vez disso, use o iterador para percorrer o conjunto e, em seguida,
    modifique-o após concluir a iteração.

    9o - Garanta a imutabilidade do conjunto quando necessário: em alguns casos,
    pode ser desejável que um conjunto seja imutável, ou seja, que seus elementos
    não possam ser adicionados, removidos ou alterados após sua criação. Para isso,
    o Java oferece a classe Collections.unmodifiableSet(), que cria uma visão
    imutável de um conjunto existente. É importante lembrar que a visão é apenas
    de leitura e qualquer tentativa de alteração do conjunto lançará uma exceção.

    10o - Considere a ordem dos elementos: algumas implementações da interface Set,
    como a TreeSet e a LinkedHashSet, mantêm uma ordem específica para os elementos.
    É importante considerar essa ordem ao escrever código que utiliza essas
    implementações. Por exemplo, se você precisar percorrer os elementos de um
    TreeSet em ordem crescente, pode usar o método iterator() ou o método forEach()
    com um Comparator apropriado.

    11o - Tenha cuidado ao usar objetos mutáveis como elementos: se você usar
    objetos mutáveis como elementos de um conjunto, é importante ter cuidado
    ao modificá-los. Se um objeto for modificado de uma maneira que altere sua
    posição no conjunto, pode ocorrer um comportamento inesperado. Por exemplo,
    se você usar uma lista como elemento de um conjunto e remover um elemento
    da lista, o conjunto poderá ficar em um estado inconsistente.

    12o - Esteja ciente das diferenças entre equals() e hashCode(): para que uma
    classe possa ser usada como elemento de um conjunto, ela deve sobrescrever os
    métodos equals() e hashCode(). É importante lembrar que esses métodos têm
    comportamentos diferentes: equals() é usado para testar a igualdade entre
    objetos, enquanto hashCode() é usado para calcular a posição do objeto no
    conjunto. Portanto, é importante garantir que esses métodos sejam consistentes
    entre si para evitar resultados inesperados.

-------------------------------------------------------------------------------
* HashSet: A classe é uma implementação da interface Set que utiliza uma tabela
hash para armazenar seus elementos. Ela não mantém uma ordem específica dos
elementos e não permite a inclusão de elementos duplicados (DISTINCT).

- Não é indexada, ou seja não é possível utilizar index para obter elementos,
então para operações deste tipo será necessário percorrer a coleção.

- Não mantém a ordem de inserção dos elementos, a coleção se ajustará de acordo
com o hashCode final gerado, porisso não é possível garantir a ordem dos
elementos. (LinkedHashSet vem para resolver isso, mantendo a ordem de inserção).

- Algumas das principais aplicações e utilidades da classe HashSet incluem:

    - Remoção de elementos duplicados: ao adicionar todos os elementos de uma
    coleção a um HashSet, os elementos duplicados serão automaticamente
    removidos, deixando apenas os elementos únicos.

    - Verificação de pertencimento: o método contains() pode ser usado para
    verificar se um determinado elemento está presente no HashSet.

    - Armazenamento de objetos complexos: o HashSet pode armazenar objetos
    complexos, como instâncias de classes personalizadas, desde que a classe
    desses objetos implemente corretamente os métodos equals() e hashCode().

    - Agilidade na recuperação de elementos: a implementação do HashSet
    utilizando tabela hash fornece acesso rápido aos elementos, com tempo
    constante em média para operações como add(), remove() e contains().

    - Cálculo de interseção, união e diferença de conjuntos: o HashSet possui
    métodos que permitem realizar operações de conjunto, como união, interseção
    e diferença.

    - Não é sincronizada: a classe HashSet não é thread-safe, o que significa
    que não é recomendado utilizá-la em ambientes concorrentes sem a devida
    sincronização.

    - Não aceita elementos duplicados: o HashSet não permite que elementos
    duplicados sejam adicionados à coleção, o que pode ser útil em muitos casos.

    - A ordem de iteração não é previsível: como o HashSet não mantém uma ordem
    específica dos elementos, a ordem em que os elementos são iterados pode variar
    de acordo com a implementação.

    - Aceita elementos nulos: o HashSet aceita elementos nulos, mas é importante
    lembrar que a comparação de elementos nulos é diferente da comparação de outros
    elementos.

    - Pode consumir muita memória: como o HashSet é baseado em tabela hash, ele pode
    consumir uma quantidade significativa de memória em relação a outras estruturas
    de dados, principalmente quando o fator de carga da tabela é alto.

    - Pode ser utilizado como base para outras implementações: a classe HashSet pode
    ser utilizada como base para outras implementações de conjuntos, como LinkedHashSet,
    que mantém a ordem de inserção dos elementos, e EnumSet, que é uma implementação
    especializada para conjuntos de enumerações.

É importante lembrar que a classe dos objetos armazenados no HashSet deve
implementar corretamente os métodos equals() e hashCode() para garantir a
correta comparação dos elementos e o funcionamento correto da tabela hash.
Além disso, por não manter uma ordem específica dos elementos, a iteração
sobre um HashSet pode ocorrer em qualquer ordem.

- Vantagens:

    - Eficiência: a classe HashSet é muito eficiente em termos de tempo de
    busca e inserção de elementos.
    Isso é devido à sua implementação baseada em hash tables, o que permite
    um acesso rápido aos elementos.

    - Garante elementos únicos: a classe HashSet garante que não haverá
    elementos duplicados na coleção, o que pode ser muito útil em algumas
    situações.

    - Interface simples: a interface da classe HashSet é simples e fácil de usar,
    permitindo que os desenvolvedores possam trabalhar com ela facilmente.

    - Eficiência na realização de operações de adição, remoção e verificação de
    pertencimento em relação a outros tipos de conjuntos, especialmente quando
    a quantidade de elementos é grande.

    - A capacidade de armazenar elementos sem ordem definida, o que pode ser útil
    em alguns casos.

- Desvantagens:

    - Não mantém ordem: a classe HashSet não mantém a ordem dos elementos
    inseridos na coleção. Se a ordem dos elementos for importante para o
    aplicativo, uma classe diferente, como LinkedHashSet, pode ser mais
    apropriada.

    - Iteração lenta: a iteração sobre os elementos do HashSet pode ser mais
    lenta do que em outras implementações da interface Set, como TreeSet ou
    LinkedHashSet, pois não há nenhuma ordem definida.

    - Consumo de memória: a classe HashSet pode consumir mais memória do que
    outras implementações da interface Set, especialmente quando há muitos
    elementos na coleção.

    - Possibilidades de sobrecarregar tabela hash: Em algumas circunstâncias,
    a tabela de hash pode ficar sobrecarregada, resultando em uma diminuição
    no desempenho das operações de conjunto.

    - Não sincronizada aumentando probabilidade de condição de corrida: A classe
    não é sincronizada, ou seja, se precisar acessá-la a partir de várias threads,
    devemos garantir as operações de sincronização manualmente ou usar a classe
    ConcurrentHashMap.


---> Pontos importantes e atenções a se tomar:

    1o - Não é thread-safe: a classe HashSet não é sincronizada, o que significa
    que não é segura para uso em ambientes concorrentes sem a devida sincronização.

    2o - Não mantém ordem de inserção: o HashSet não mantém uma ordem específica
    dos elementos, o que significa que a ordem em que os elementos são inseridos
    pode não ser a ordem em que são iterados.

    3o - Não permite elementos duplicados: o HashSet não permite elementos
    duplicados. Se um elemento duplicado for adicionado à coleção, a operação
    será ignorada.

    4o - Aceita elementos nulos: o HashSet permite a adição de elementos nulos,
    mas é importante lembrar que a comparação de elementos nulos é diferente da
    comparação de outros elementos.

    5o - Desempenho pode ser afetado pelo fator de carga: o desempenho da classe
    HashSet pode ser afetado pelo fator de carga da tabela hash. É recomendado
    manter o fator de carga abaixo de 0,75 para um desempenho ideal.

    6o - O método equals() é utilizado para comparar elementos: o HashSet utiliza
    o método equals() para comparar elementos, o que significa que os elementos
    adicionados devem implementar este método corretamente.

    7o - Hashcode: o HashSet usa o método hashCode() para determinar a posição
    do elemento na tabela de hash. Certifique-se de que a classe do objeto tenha
    implementado corretamente este método.

    8o - A classe HashSet pode ser utilizada como base para outras implementações:
    a classe HashSet pode ser utilizada como base para outras implementações de
    conjuntos, como LinkedHashSet e TreeSet.

    9o - Adicionar elementos: você pode adicionar elementos ao HashSet usando o
    método add(). O método retorna true se o elemento foi adicionado com sucesso
    e false se o elemento já estava presente no conjunto.

    10o - Performance: o HashSet tem um desempenho melhor em operações de adição,
    remoção e busca do que a maioria das outras estruturas de dados em Java, como
    o ArrayList. No entanto, o desempenho pode ser afetado se a função hashCode()
    não for bem implementada ou se houver muitas colisões.

-------------------------------------------------------------------------------
* LinkedHashSet: A classe é uma implementação da interface Set em Java que usa
uma lista duplamente encadeada para armazenar os elementos na ordem em que foram
inseridos, além de garantir que não há elementos duplicados no conjunto.
Ela herda as características da classe HashSet e adiciona a capacidade de manter
a ordem dos elementos inseridos.

- Resolve problema anterior da classe Hashset, garantindo a ordem de inserção dos
elementos na ordem em que foram adicionados.

- Algumas aplicações e utilidades da classe LinkedHashSet em Java incluem:

    - Manter a ordem de inserção dos elementos: Como mencionado anteriormente,
    a classe LinkedHashSet mantém a ordem dos elementos inseridos, o que pode
    ser útil em muitos casos.

    - Remoção de elementos: Quando você remove um elemento de um LinkedHashSet,
    ele é removido da lista na ordem em que foi inserido.

    - Eliminação de elementos duplicados: Como qualquer conjunto em Java, um
    LinkedHashSet garante que não há elementos duplicados no conjunto.

    - Criação de uma cópia ordenada de um conjunto: Se você deseja criar uma
    cópia ordenada de um conjunto em Java, você pode usar um LinkedHashSet
    para armazenar os elementos na ordem em que foram inseridos.

    - Implementação de cache: Um LinkedHashSet pode ser usado como uma
    implementação simples de cache, onde os elementos mais recentemente
    acessados são mantidos no topo da lista.

    - Implementação de históricos: Um LinkedHashSet pode ser usado para manter
    um histórico de ações ou eventos em ordem cronológica, onde os elementos
    mais recentes são adicionados no topo da lista.

    - Desempenho: A classe LinkedHashSet tem um desempenho semelhante ao da
    classe HashSet em termos de adição, remoção e verificação da presença de
    elementos. No entanto, o desempenho da iteração é um pouco mais lento,
    pois a classe LinkedHashSet precisa percorrer a lista duplamente encadeada
    para manter a ordem dos elementos.

Em resumo, a classe LinkedHashSet é uma excelente escolha quando você precisa
manter a ordem de inserção dos elementos, remover elementos da lista na ordem
em que foram inseridos ou garantir que não há elementos duplicados no conjunto.

- Vantagens:

    - Mantém a ordem de inserção dos elementos: Mantém a ordem em que os
    elementos foram inseridos no conjunto.
    Isso pode ser útil em várias situações, como quando você precisa exibir os
    elementos em ordem cronológica.

    - Evita duplicatas: Evita a inserção de elementos duplicados no conjunto.
    Isso pode ser útil quando você precisa garantir que cada elemento no
    conjunto seja único.

    - Implementação eficiente: É uma implementação eficiente da interface Set
    em Java. As operações de adição, remoção e busca de elementos são muito
    rápidas, pois a classe usa um hash table internamente.

    - Iteração ordenada é garantida: Permite iterar sobre os elementos do conjunto
    na ordem em que foram inseridos.
    Isso pode ser útil quando você precisa exibir ou processar os elementos em
    uma ordem específica.

    - Funcionalidades adicionais: Oferece vários métodos adicionais, como o método
    clone() para criar uma cópia do conjunto e o método removeAll() para remover
    vários elementos de uma só vez.

    - Permite a fácil conversão entre tipos de coleções: o LinkedHashSet implementa
    a interface Set, o que significa que é fácil converter de um LinkedHashSet para
    outras implementações de Set ou vice-versa, como o HashSet, o TreeSet, etc.

    - É eficiente para remover elementos: a remoção de elementos em um LinkedHashSet
    é muito eficiente, pois a posição do elemento na lista vinculada é conhecida e,
    portanto, pode ser removido rapidamente.

    - Permite iterar os elementos em ordem crescente ou decrescente: o LinkedHashSet
    possui métodos que permitem a iteração dos elementos em ordem crescente ou
    decrescente, facilitando a implementação de algumas funcionalidades que exigem a
    ordenação dos elementos.

- Desvantagens:

    - Maior consumo de memória: o LinkedHashSet precisa armazenar os elementos em
    uma lista vinculada além de manter um mapa hash para realizar as operações de
    busca.
    Isso pode resultar em um consumo de memória maior em comparação com outras
    implementações de Set.

    - Pode ter uma performance pior em comparação com HashSet para algumas operações:
    embora o LinkedHashSet tenha uma performance similar ao HashSet para adicionar,
    remover e buscar elementos, ele pode ter uma performance um pouco pior em alguns
    casos devido à necessidade de manter a ordem dos elementos.

    - Iteração é mais lenta do que em uma lista simples: embora o LinkedHashSet
    possua uma ordem de inserção dos elementos, a iteração é um pouco mais lenta
    do que em uma lista simples, devido à necessidade de verificar a tabela hash
    antes de retornar cada elemento.

    - Não é thread-safe: assim como outras implementações da interface Set, o
    LinkedHashSet não é thread-safe, ou seja, não é seguro utilizá-lo em ambientes
    concorrentes sem a devida sincronização.

    - Não é recomendado para elementos grandes: o LinkedHashSet pode ter uma
    performance ruim para elementos muito grandes, pois o processo de hash para
    estes elementos pode ser mais lento. Nesse caso, pode ser mais adequado
    utilizar outras estruturas de dados.

---> Pontos importantes e atenções a se tomar:

    1o - A ordem dos elementos é mantida: uma das principais características do
    LinkedHashSet é a manutenção da ordem de inserção dos elementos. É importante
    lembrar que a ordem dos elementos pode mudar se um elemento já existente for
    adicionado novamente.

    2o - Não permite elementos duplicados: o LinkedHashSet não permite a inclusão
    de elementos duplicados. Ao tentar adicionar um elemento duplicado, a operação
    de adição falhará silenciosamente e não terá efeito.

    3o - Não é sincronizado: o LinkedHashSet não é thread-safe, portanto, se for
    usado em um ambiente concorrente, será necessário sincronizar manualmente as
    operações para evitar condições de corrida.

    4o - Pode ter um consumo de memória maior: como mencionado anteriormente, o
    LinkedHashSet pode ter um consumo de memória maior do que outras implementações
    de Set, especialmente se muitos elementos forem adicionados.

    5o - O desempenho pode ser afetado por elementos grandes: a performance do
    LinkedHashSet pode ser afetada negativamente se muitos elementos grandes forem
    adicionados, pois o processo de hash para estes elementos pode ser mais lento.

    6o - Iteração pode ser mais lenta do que em uma lista simples: embora a iteração
    seja ordenada, ela pode ser um pouco mais lenta do que em uma lista simples,
    devido à necessidade de verificar a tabela hash antes de retornar cada elemento.

    7o - Escolha cuidadosamente a implementação do Set: dependendo da aplicação,
    outras implementações de Set podem ser mais adequadas do que o LinkedHashSet.
    Por exemplo, se não for necessário manter a ordem de inserção, o HashSet pode
    ser uma escolha melhor devido a sua performance mais rápida.

    8o - Pode ser inicializado com uma capacidade e fator de carga: ao criar um
    LinkedHashSet, é possível especificar a capacidade inicial e o fator de carga.
    Isso pode ser útil para evitar realocações de memória frequentes e melhorar a
    performance em casos em que o tamanho do conjunto é conhecido com antecedência.

    9o - Pode ser utilizado em conjunto com outras estruturas de dados: LinkedHashSet
    pode ser utilizado em conjunto com outras estruturas de dados para resolver
    problemas mais complexos. Por exemplo, ele pode ser utilizado para remover
    elementos duplicados de uma lista enquanto mantém a ordem de inserção.

    10o - Pode ser utilizado para implementar algoritmos de cache: o LinkedHashSet
    pode ser utilizado para implementar algoritmos de cache simples. Ao adicionar
    um elemento a ele, é possível verificar se o tamanho do conjunto excede um
    determinado limite e remover o elemento mais antigo se necessário.

    11o - Não é adequado para elementos mutáveis: o LinkedHashSet utiliza o hash do
    objeto para determinar sua posição na tabela hash. Portanto, se um objeto mutável
    for utilizado como elemento do LinkedHashSet, seu hash pode mudar e causar
    problemas de desempenho ou comportamento inesperado.

    12o - As operações de adição, remoção e busca são rápidas: as operações de adição,
    remoção e busca no LinkedHashSet têm complexidade O(1) em média. No entanto, em
    casos raros, a complexidade pode ser O(n), dependendo da forma como a tabela hash
    é construída e dos elementos que estão sendo armazenados.

-------------------------------------------------------------------------------
* SortedSet: É uma interface que extends a interface Set e define um conjunto
ordenado de elementos únicos. Como o nome sugere, um SortedSet mantém os
elementos em ordem classificada e não permite elementos duplicados.
A ordem pode ser definida de várias maneiras, dependendo da implementação, como
a ordem natural dos elementos ou uma ordem definida por um comparador externo.

As classes que implementam essa interface fornecem funcionalidades adicionais em
relação à interface Set, como acesso aos elementos por posição e subconjuntos
definidos por um intervalo de elementos.

Em geral, o uso de classes que implementam a interface SortedSet pode ser uma boa
escolha em aplicações que exigem a ordenação automática de elementos e acesso
eficiente a subconjuntos de elementos.

- Algumas das principais aplicações e utilidades de um SortedSet são:

    - Ordenação de elementos: um SortedSet pode ser usado para manter os elementos
    em ordem classificada, o que pode ser útil em várias aplicações, como
    classificação de dados, exibição de informações em ordem alfabética, filtragem
    de dados com base em uma ordem definida e assim por diante.

    - Conjunto sem duplicatas: um SortedSet não permite elementos duplicados, o que
    pode ser útil em muitos casos em que é importante garantir que não haja duplicatas
    em um conjunto de dados.

    - Eficiência de busca: as implementações de SortedSet usam uma estrutura interna,
    como uma árvore binária de busca ou uma tabela hash, para manter os elementos em
    ordem e pesquisar rapidamente um elemento em particular.
    Isso torna a busca de elementos em um SortedSet muito eficiente em comparação com
    outras estruturas de dados.

    - Subconjuntos ordenados: um SortedSet permite a criação de subconjuntos ordenados
    de seus elementos, usando os métodos subSet, headSet e tailSet.
    Isso pode ser útil em várias aplicações, como busca por um intervalo específico de
    valores, seleção de uma faixa de dados com base em uma condição de filtro e assim
    por diante.

Em resumo, um SortedSet é uma estrutura de dados útil para manter um conjunto ordenado
de elementos únicos. Ele pode ser usado em uma variedade de aplicações que exigem
eficiência de busca, ordenação de elementos e a garantia de que não haja duplicatas.

---> Principais Classes que Implementam ele:

    * TreeSet: implementa um SortedSet usando uma árvore binária de busca. Os elementos
    são mantidos em ordem natural ou em uma ordem definida por um Comparator externo.
    - É útil quando se precisa manter uma coleção de elementos em ordem classificada.
    Por exemplo, pode ser usado para manter um conjunto de palavras em ordem alfabética
    ou para classificar e filtrar dados.

    * ConcurrentSkipListSet: implementa um SortedSet usando uma lista ligada de nós,
    cada um contendo uma chave e um conjunto de nós adjacentes. A lista é ordenada
    usando a ordem natural dos elementos ou um Comparator externo.
    - É útil quando é necessário manter uma lista ordenada de elementos em um ambiente
    multithreaded. Por exemplo, pode ser usado para manter uma lista de threads em
    execução em ordem de prioridade.

    * EnumSet: implementa um SortedSet para enumerações, mantendo os elementos em
    ordem natural da enumeração.
    - É útil para representar conjuntos de enumerações em um programa. Por exemplo,
    pode ser usado para representar os dias da semana ou os estados de uma máquina
    de estados finita.

    * CopyOnWriteArraySet: implementa um SortedSet usando um array de objetos.
    A estrutura interna do array é modificada de forma thread-safe usando uma
    cópia do array original.
    É útil quando é necessário manter uma coleção thread-safe de elementos,
    especialmente em ambientes em que as leituras são muito mais frequentes
    do que as gravações. Por exemplo, pode ser usado para manter uma lista
    de assinantes de eventos em um aplicativo.

- Vantagens:

    - Ordenação automática: A principal vantagem de usar uma classe que implementa
    a interface SortedSet é que os elementos são automaticamente ordenados na ordem
    definida pela classe.
    Isso pode economizar tempo e esforço para ordenar os elementos manualmente.

    - Operações mais eficientes: As classes que implementam a interface SortedSet
    oferecem operações de busca e acesso a elementos mais eficientes do que outras
    classes de conjunto, como HashSet.
    Isso é possível graças à ordenação dos elementos.

    - Conjuntos limitados por intervalo: As classes que implementam a interface
    SortedSet permitem criar subconjuntos com base em um intervalo de elementos.
    Isso pode ser útil em várias aplicações, como em jogos de cartas ou em
    visualização de dados.

    - Redução de código: A ordenação automática dos elementos pode reduzir a
    quantidade de código necessário para realizar tarefas comuns em que a
    ordenação é necessária, como em algoritmos de pesquisa binária.

- Desvantagens:

    - Desempenho inferior em inserção e remoção: As classes que implementam a
    interface SortedSet geralmente têm um desempenho inferior em operações de
    inserção e remoção de elementos em relação a outras classes de conjunto,
    como HashSet.
    Isso ocorre porque a ordenação dos elementos precisa ser mantida e
    atualizada durante essas operações.

    - Complexidade do código: A implementação de classes que usam a interface
    SortedSet pode ser mais complexa do que a implementação de classes que usam
    outras interfaces de conjunto, devido à necessidade de manter a ordenação
    dos elementos.

    - Custo computacional: A ordenação automática dos elementos pode ter um custo
    computacional mais alto do que outras implementações de conjunto.
    Isso pode ser um problema em aplicações que requerem desempenho de alto nível
    e grande volume de dados.

---> Diferenças de uso para cada classe que implementa:

* TreeSet:
    - Implementação baseada em árvore binária balanceada (Red-Black Tree);
    - Mantém os elementos em ordem crescente;
    - Fornece métodos adicionais para trabalhar com elementos em uma posição específica na ordem;
    - É adequada para casos em que é necessário manter os elementos em ordem crescente.

* ConcurrentSkipListSet:
    - Implementação baseada em uma estrutura de dados de lista ligada parcialmente ordenada;
    - Mantém os elementos em ordem crescente;
    - Permite acesso concorrente seguro aos elementos do conjunto;
    - É adequada para casos em que há múltiplas threads trabalhando simultaneamente no conjunto.

* ImmutableSortedSet:
    - Implementação imutável de um conjunto ordenado de elementos;
    - Mantém os elementos em ordem crescente;
    - Não permite a adição, remoção ou modificação de elementos após a criação;
    - É adequada para casos em que os elementos são conhecidos antecipadamente e não serão modificados.