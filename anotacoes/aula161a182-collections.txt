-- Data - (Estudos feitos em Java e agora documentado)
-- link: -
-- Mais informações sobre serialização: -

Intermediário: Mais específico no Java


/* Fluxograma Collections Framework Hierarchy in Java:
                     +----+----+
                    | Collection|                                     +---->   Map  <---+ Interface separada da hierarquia
                     +----+----+                                      |                 |
                          |                                 +---------+---------+-------+-------+
             +------------+-----------+                     |                   |               |
             |                        |                   HashMap          LinkedHashMap     TreeMap
           Set                      List                    |                   |               |
             |                        |                   Hashtable        IdentityHashMap   WeakHashMap
    +--------+-------+       +--------+-------+              |                                  |
    |                |       |                |           Properties                         SortedMap
 HashSet     SortedSet     ArrayList       LinkedList
    |                |            |          /      \
 LinkedHashSet  NavigableSet   Vector  DoublyLinkedList
                                             |
                                          Stack
                                             |
                                       PriorityQueue
 */

/* Tabela de calculos Big-O para as coleções do java:
(Com gráficos: https://www.bigocheatsheet.com/)

- List implementations:
                       get   add   contains  next remove(0)  iterator.remove
 ArrayList             O(1)  O(1)  O(n)      O(1) O(n)       O(n)
 LinkedList            O(n)  O(1)  O(n)      O(1) O(1)       O(1)
 CopyOnWrite-ArrayList O(1)  O(n)  O(n)      O(1) O(n)       O(n)
---------------------------------------------------------------------------
 - Set implementations:
                       add       contains  next      notes
 HashSet               O(1)      O(1)      O(h/n)    h is the table capacity
 LinkedHashSet         O(1)      O(1)      O(1)
 CopyOnWriteArraySet   O(n)      O(n)      O(1)
 EnumSet               O(1)      O(1)      O(1)
 TreeSet               O(log n)  O(log n)  O(log n)
 ConcurrentSkipListSet O(log n)  O(log n)  O(1)
---------------------------------------------------------------------------
 - Map implementations:
                       get       containsKey  next      Notes
 HashMap               O(1)      O(1)         O(h/n)    h is the table capacity
 LinkedHashMap         O(1)      O(1)         O(1)
 IdentityHashMap       O(1)      O(1)         O(h/n)    h is the table capacity
 EnumMap               O(1)      O(1)         O(1)
 TreeMap               O(log n)  O(log n)     O(log n)
 ConcurrentHashMap     O(1)      O(1)         O(h/n)    h is the table capacity
 ConcurrentSkipListMap O(log n)  O(log n)     O(1)
---------------------------------------------------------------------------
 - Queue implementations:
                       offer     peek  poll      size
 PriorityQueue         O(log n)  O(1)  O(log n)  O(1)
 ConcurrentLinkedQueue O(1)      O(1)  O(1)      O(n)
 ArrayBlockingQueue    O(1)      O(1)  O(1)      O(1)
 LinkedBlockingQueue   O(1)      O(1)  O(1)      O(1)
 PriorityBlockingQueue O(log n)  O(1)  O(log n)  O(1)
 DelayQueue            O(log n)  O(1)  O(log n)  O(1)
 LinkedList            O(1)      O(1)  O(1)      O(1)
 ArrayDeque            O(1)      O(1)  O(1)      O(1)
 LinkedBlockingDeque   O(1)      O(1)  O(1)      O(1)
 ---------------------------------------------------------------------------
*/

/* Descrições sobre as complexidades:

    As notações de complexidade Big-O são usadas para descrever o tempo de
    execução ou espaço de memória necessários para um algoritmo à medida
    que o tamanho da entrada aumenta. Essas notações são escritas usando
    a notação O() e indicam a ordem de crescimento do algoritmo à medida
    que o tamanho da entrada aumenta. Aqui estão as principais notações
    de complexidade Big-O e seus significados:

    - O(1): Tempo de execução constante. Isso significa que o algoritmo
    leva a mesma quantidade de tempo, independentemente do tamanho da
    entrada.
    * Exemplo: acesso a um elemento em uma matriz.

    - O(log n): Tempo de execução logarítmico. Isso significa que o tempo
    de execução cresce proporcionalmente ao logaritmo do tamanho da entrada.
    * Exemplo: busca binária em uma lista ordenada.

    - O(n): Tempo de execução linear. Isso significa que o tempo de execução
    cresce proporcionalmente ao tamanho da entrada.
    * Exemplo: percorrer todos os elementos de uma lista.

    - O(n log n): Tempo de execução quase-linear. Isso significa que o tempo
    de execução cresce proporcionalmente ao tamanho da entrada multiplicado
    pelo logaritmo do tamanho da entrada.
    * Exemplo: algoritmos de classificação eficientes, como o mergesort ou o
    heapsort.

    - O(n^2): Tempo de execução quadrático. Isso significa que o tempo de
    execução cresce proporcionalmente ao quadrado do tamanho da entrada.
    * Exemplo: algoritmos de ordenação com desempenho inferior, como
    bubble sort ou selection sort.

    - O(2^n): Tempo de execução exponencial. Isso significa que o tempo de
    execução cresce exponencialmente em relação ao tamanho da entrada.
    * Exemplo: algoritmos de força bruta, como a resolução do problema do
    caixeiro-viajante.

    - O(n!): Tempo de execução fatorial. Isso significa que o tempo de execução
    cresce fatorialmente em relação ao tamanho da entrada.
    * Exemplo: resolução do problema de permutação.

    Geralmente, um algoritmo com complexidade Big-O menor é preferível, pois
    requer menos recursos computacionais à medida que o tamanho da entrada
    aumenta. No entanto, em muitos casos, é necessário comprometer entre a
    eficiência do algoritmo e a simplicidade de implementação ou outros
    requisitos do sistema.
*/

-------------------------------------------------------------------------------
// Classes/métodos aboradados neste package:
* equals() e hashCode():
    - Utilizado para comparar Objetos, ambos devem ser concistentes entre sí.
    - Equals e HashCode são muito utilzados em Listas complexas e com maior
      performance, como HashSet e HashMap. Pois ao invés de comparar elemento
      a elemento da lista, eles utilizam o hashCode como index, assim podemos
      acessar o Objeto da lista diretamente sem precisar realizar a iteração
      elemento a elemento como algoritmos mais simples fazem.

    - Atenções sobre:
        CUIDADOS ao trabalhar com Objetos mutáveis e hashCode pois o hash muda,
        e assim pode gerar possíveis inconcistências ao utilizar métodos de
        busca e etc!
        - Sempre utilizar atributos constantes para gerar os hashs e garantir
        imutabilidade.

    - Regras para a implementação do equals em um Object Model:

      - Reflexivo: x.equals(x) == true para tudo != null;
      - Simétrico: para x e y != null, se x.equals(y) == true logo y.equals(x)
      também tem que ser true.
      - Transitividade: para x, y e z != null,
      se x.equals(y) && x.equals(z) == true então y.equals(z) tambeḿ tem que
      ser true.
      - Consistente: para todas as chamadas, x.equals(x) sempre retorna true
      desde que x != null.
      para x != null, x.equals(null) tem que retorna false;

-------------------------------------------------------------------------------
* Interface List<T>:
    A interface List é uma das interfaces mais importantes do framework de
    coleções do Java. Ela define um contrato para classes que representam
    sequências ordenadas de elementos e oferece uma série de métodos para
    manipulação dessas sequências.
    - Interface mais genérica utilizada neste contexto.
    - Programação Orientada a Interface: As coleções no java são bem coesas
    e essa abordagem é bastante utilizada pois ajuda na manutenção do cod.

-------------------------------------------------------------------------------
* Classe que implementa List<T>: ArrayList<T>:
    - A classe ArrayList<T> é uma implementação da interface List<T> que usa
    uma matriz interna para armazenar seus elementos. Ao adicionar um
    elemento a uma ArrayList<T>, a matriz interna pode precisar ser
    redimensionada, o que pode ser um processo lento se a lista for grande.
    Portanto, se você precisa adicionar muitos elementos a uma ArrayList<T>,
    considere usar um LinkedList<T> em vez disso.

    - O método add() da ArrayList<T> adiciona um elemento ao final da lista.
    Se você precisar adicionar um elemento em uma posição específica, use o
    método add(int index, T element) em vez disso. No entanto, tenha cuidado
    ao adicionar elementos em posições intermediárias, pois isso pode exigir
    que todos os elementos subsequentes sejam movidos para cima na matriz
    interna.

    - A ArrayList<T> é uma estrutura de dados mutável, o que significa que os
    elementos podem ser alterados a qualquer momento. Isso pode ser útil em
    alguns casos, mas também pode tornar seu código mais difícil de entender
    e depurar. Considere usar coleções imutáveis, como a List<T> fornecida
    pela classe Collections, sempre que possível.

    - A ArrayList<T> não é sincronizada, o que significa que não é segura para
    uso em threads concorrentes. Se você precisar compartilhar uma lista entre
    várias threads, considere usar uma lista sincronizada ou um
    CopyOnWriteArrayList<T> em vez disso.

    - A ArrayList<T> implementa a interface Serializable, o que significa que
    pode ser serializada e desserializada facilmente. Isso pode ser útil ao
    salvar e carregar listas em um arquivo ou enviar listas pela rede.

-------------------------------------------------------------------------------
* SortingLists:
    - Ordenando listas com o método Collections.sort(): método sobrecarregado,
    podemos passar apenas a coleção que será ordenada, ou também acrescentar
    um obj que implemente Comparator<T> no segundo parâmetro.

    - Para ordenar a coleção, o obj em ordenação desta lista precisa implementar
    Comparable<T> ou então será necessário criar uma instância Comparator<T> e
    nele definir a regra de ordenação para o método compare().
    (Oque torna um obj maior>, menor< ou igual== a outro?).
        - Obs: Mesma regra definida em um obj que implements Comparable<T>.

    - Quando utilizar Comparable<T> ou Comparator<T> ?
        Implementamos o Comparable<T> num objeto quando queremos definir uma
        regra "Geral/Natural" de ordenação, essa seria a regra "default" de
        ordenação, ou seja, válida para o programa como um "tôdo" pois toda
        vez que o Java precisar comparar dois objetos, ele utilizará essa
        regra como critério, "chamando" o método compareTo(Object otherObj);

        - Implementamos o Compartor<T> quando queremos alterar por algum
        motivo essa regra inicial apenas em pontos específicos no programa,
        alterando assim essa ordenação "Natural/Default" do Objeto em
        questão.
            - Também podemos utilizar essa abordagem quando o objeto em
            ordenação não estiver sob nosso controle, por algum motivo
            como API's de terceiros ou classes que não conhecemos bem
            o seu comportamento/uso geral no programa, então para isso
            criamos ou implementamos um Comparator<T> e definimos a
            regra, sem afetar a Classe do Objeto em ordenação em sí.

        - Dica: Caso queira utilizar como critério de comparação Objetos
        internos a outros em aninhamento como por exemplo ordenar uma
        lista de pedidos com base no nome dos clientes, ou ir além, basta
        na implementação do Comparator<T> utilizar o get multiplas vezes
        até encontrar o Objeto do nível correto:

          @Override
          public int compare(Pedido p1, Pedido p2) {
              String nomeCliente1 = p1.getCliente().getNome(); // -> Aqui poderia ter get().get().get()...
              String nomeCliente2 = p2.getCliente().getNome(); // Até chegar no nível do Objeto desejado.
              return nomeCliente1.compareTo(nomeCliente2);
          }

    - Além dessa implementação necessária para a ordenação de elementos,
    também é necessário a implementação correta do equals() e hashCode().

    - Collections: Classe 100% estática utilizada como Utilitário no contexto
    de coleções no Java.

-------------------------------------------------------------------------------
* BinarySearch:
    - É um dos métodos estáticos do Collections.binarySearch(numbersList, 6);
    Aonde ´numberList´ é a coleção e ´6´ é o index do elemento em search.
    - Podemos também aplicar esse método em Arrays nativos do Java,
      porém o mesmo deve garantir a ordenação dos elementos.
    - Para utilizar é necessário passar uma coleção ordenada (sort()),
    pois ele utiliza tecnicas de programação que otimizam a performance.

    - REGRA: O retorno será o index do elemento, com algumas convenções sendo
     elas:
        - A Diferença dele para um indexOf() é que além de retornar NEGATIVO
        quando um Objeto não existe na lista retorna também em qual posição
        o elemento deveria estar para manter a lista ordenada.

        - Quando EXISTE o elemento em busca, retorna um inteiro POSITIVO que
        representa o index dele.

        - Quando NÃO existe o elemento em busca, retorna um inteiro NEGATIVO
        que representa o index em que o elemento deve ser inserido para manter
        a lista ordenada subtraindo 1. (-(ponto de inserção) -1)
        Aonde "ponto de inserção" == index aonde o elemento deveria estar para
        manter a lista ordenada.
            - Subtraí 1 pois se o valor retornado fosse 0 não saberiamos se é
            o resultado Exists do elemento, ou se é a posição em que o elemento
            deveria estar, ou seja NotExists.
                - OU SEJA, ele garante que só irá retornar POSITIVO se o elemento
                Exists, caso contrario o retorno será sempre NEGATIVO.

                - PORISSO deve se ATENTAR ao criar coleções com valores NEGATIVOS,
                pois ai iria adicionar mais complexidade nesta lógica,
                e a matematica que deverá ser aplicada após o processamento,
                fazendo assim com que a transformação correta do elemento teria
                que levar em consideração esse fator.

            - FÓRMULA em casos de retorno NEGATIVO indicando que o elemento não
            exists na lista, sendo necessário assim transformar o index
            corretamente para obter o index real no qual o elemento deveria estar
            para manter a lista organizada/sorted:

                  int realIndex = 0;
                  if (indexOfElementWithBinarySearched < 0){
                      realIndex = -(indexOfElementWithBinarySearched + 1);

                      ... Aqui podemos realizar a criação e inserção do Objeto na lista,
                      de uma forma em que mantém a lista organizada na regra definida em Comparable<T>

                  } else { // POSITIVO não é preciso, pois o index vem corretamente.
                      realIndex = indexOfElementWithBinarySearched;
                  }

    - Vantagens de se utilizar a busca binária: APENAS e só APENAS se aplica em
    listas Sorted/Ordenadas!!

         - A vantagem de utilizar o método binarySearch() é a eficiência em
         encontrar um elemento de uma lista ordenada. A busca binária é um
         algoritmo eficiente para encontrar um elemento de uma lista ordenada,
         pois a busca é feita pela metade da lista em cada iteração, reduzindo
         drasticamente o número de comparações necessárias.

         - Em comparação com uma busca linear, em que cada elemento da lista é
         verificado um por um até que o elemento procurado seja encontrado, a
         busca binária é significativamente mais rápida para listas maiores.
         Isso se deve ao fato de que a BUSCA BINÁRIA corta a lista pela METADE
         a cada iteração, enquanto a busca LINEAR percorre TODOS os elementos
         da lista.

    - Desvantagens de se utilizar a busca binária:

        - A lista deve estar ordenada: A busca binária requer que a lista esteja
        ordenada em ordem crescente ou decrescente antes de executar a busca.
        Isso significa que, se a lista não estiver ordenada corretamente, será
        necessário ordená-la antes de realizar a busca, o que pode ser um
        processo custoso em termos de tempo.

        - Não é adequado para listas pequenas: A busca binária é mais eficiente
        para listas grandes, pois seu desempenho aumenta exponencialmente à
        medida que o tamanho da lista aumenta. Para listas pequenas, o desempenho
        da busca binária pode ser comparável ou até mesmo pior do que outras
        técnicas de busca, como a busca linear.

        - Não é adequado para listas mutáveis: A busca binária é projetada para
        ser usada com listas imutáveis, ou seja, listas que não mudam durante a
        busca. Se a lista estiver sendo modificada enquanto a busca estiver em
        andamento, pode haver problemas com a ordem dos elementos e o resultado
        da busca pode ser impreciso.

        - Não é adequado para tipos de dados complexos: A busca binária é melhor
        usada com tipos de dados simples, como inteiros ou caracteres. Para tipos
        de dados complexos, como objetos personalizados, pode ser necessário
        definir uma ordem de classificação personalizada ou sobrescrever o método
        compareTo() para que a busca binária funcione corretamente.

        - Requer que a lista implemente a interface List: O método binarySearch()
        do Collections só pode ser usado em listas que implementam a interface
        List. Se você estiver usando uma lista que não implementa a interface
        List, será necessário usar uma implementação personalizada da busca binária.

        - Pode retornar resultados imprecisos ou inesperados: Em alguns casos, o
        método binarySearch() pode retornar resultados imprecisos ou inesperados,
        especialmente se a lista contiver elementos duplicados. Nesses casos, o
        método pode retornar qualquer índice correspondente a um elemento
        encontrado, mas não necessariamente o índice do elemento desejado.

        - Não é adequado para buscas por critérios complexos: A busca binária é
        adequada para encontrar elementos por valor exato. No entanto, se você
        precisar procurar por elementos com base em critérios mais complexos,
        como faixa de valores ou correspondência parcial de strings, a busca
        binária pode não ser a melhor opção.

        - A complexidade da implementação: Implementar a busca binária requer
        conhecimento prévio e pode ser um processo complexo, especialmente se
        você estiver lidando com casos não triviais, como a busca em listas
        multidimensionais.

        - Pode ser menos eficiente em cenários de memória limitada: A busca
        binária requer que a lista esteja ordenada em memória antes de executar
        a busca, o que pode ser um problema em cenários com limitações de memória.
        Em tais cenários, outras técnicas de busca, como a busca linear ou a busca
        hash, podem ser mais eficientes.

-------------------------------------------------------------------------------
* List to Array Convertion: Conversões Array nativo <=> List e vici versa.

    - Transformando uma List<E> em um Array:
        Object[] objects = inteiros.toArray(); -> sem especificar ele retorna Objects
        Integer[] listToArray = integersList.toArray(new Integer[0]);

    - Transformando um Array em uma List<E>:
        List<Integer> integers = Arrays.asList(listToArray); // linka os dois arrays em uma List<T>
        //integers.add(4); -> Operação inválida pois Arrays não podem ser redimensionados.
        integers.set(2, 4); // Operação VÀLIDA pois não estemos alterando o dimensionamento do array (size)

        List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray)); // SOLUÇÃO: quebra o link

    - Arrays.asList():
        - É otimizado para criar uma lista de tamanho fixo a partir de um array
         existente e, portanto, é mais eficiente em termos de memória e
         desempenho. Além disso, o método retorna uma visualização da lista,
         o que significa que não é criada uma nova instância de lista. Em vez
         disso, é criado um objeto interno que atua como uma "janela" para o
         array subjacente, permitindo que você trabalhe com a lista como se
         fosse uma lista regular.

             - SOLUÇÃO: Para quebrar esse vínculo utilizar o array no construtor
             e criar uma nova instância de List<T>:
             List<Integer> pamonha = new ArrayList<>(Arrays.asList(listToArray));

