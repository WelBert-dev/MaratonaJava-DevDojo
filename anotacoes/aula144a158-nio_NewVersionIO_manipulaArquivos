-- Data 06/01/2023 até 00/00/2023 (Estudos feitos em .Java e agora documentado)
-- link:
-- Mais informações sobre nio (new IO): https://docs.oracle.com/javase/tutorial/essential/io/legacy.html

Intermediário: Mais especifico no Java


- Introdução: Nova forma de se trabalhar com o IO, mais otimizado e maior coerência entre classes.


[Class File] <=====================================> [Interface Path] -> substitui a classe File por Path
     /\                                                     /\
     ||                                                     ||
     ||                                                [Class Paths] -> Utilizada para dar origem a uma interface Path
     ||
[Class Util Files] -> Todos os métodos de File foram passados para Files (Estáticos)

// Classes aboradads neste package:
// Path (Substitui a class File)
// Paths (Utilizada principalmente para instânciar um Path)
// Files (100% Estática ou seja Utils com todas as operações de File) criar, verificar se existe e etc..
// BasicFileAttributes (Utilizada para manipulações nos atributos de um Path/Arquivo).
    // Correspondente para settar valores: BasicFileAttributesView
    // POLIMORFISMO para S.O's:
        // DosFileAttributes (Winodows) Também possue o correspondente DosFileAttributesView para settar.
        // PosixFileAttributes (Unix like) Também possue o correspondente PosixFileAttributesView para settar.
// DirectoryStream (Classe mais básica para interar sobre level 1 da arvore de diretórios).
// SimpleFileVisitor (Classe que ao EXTENDS podemos interar recursivamente (ALL) abaixo da arvore de diretórios.
// PathMatcher (Classe utilizada neste contexto para filtrar por um padrão (globExpression)) e selecionar arquivos especificos.
// ZipOutputStream (Classe utilizada para apartir de uma lista de Paths zipar esses arquivos e salvar em outro Path).


---------------------- // Path: Interface devido ao POLIMORFISMO de S.O's compatíveis com o Java
Ou seja, utilizamos como variável de referência esse genérico para apartir da classe Paths pegar uma instância
correta de acordo com o S.O e utilizamos desta programação orientada a interface.
- Substitui a antiga classe File (Ou seja é uma representação do arquivo em Obj na memória).
- Pegamos uma instância com o método estático Paths.get("Caminho");
    - Por ser um varargs (...) podemos passar pasta a pasta do caminho utilizando "," Paths.get("C:", "pamonha", "arq.txt");

Extends: Comparable<Path>, Iterable<Path>, Watchable
ou seja, podemos utilizar o método compareTo() e etc...

- Obs: Não é garantido que o arquivo realmente existe, ou seja não é garantido que o Path é válido!
- Para saber se é válido devemos utilizar o método estático Files.notExists(filePath);
- E para criar utilizamos Files.createFile(filePath);

- Com um objeto dele é possível obter todas informações referênte ao arquivo em sí
  como data de criação, modificação, diretório pai e etc...

---> Pontos a se considerar quando se utiliza:
    1o - Sistema operacional: É importante levar em consideração o sistema operacional em que
         o código será executado, pois algumas convenções de caminhos de arquivos podem ser
         diferentes em sistemas operacionais diferentes.

    2o - Permissões de arquivos: É importante verificar as permissões de arquivos e diretórios
         ao trabalhar com a classe Path, para garantir que o código tenha acesso aos arquivos necessários.

    3o - Nomes de arquivos e diretórios: É importante ter cuidado ao especificar nomes de arquivos e diretórios,
         pois alguns nomes podem não ser válidos em alguns sistemas operacionais.

    4o - Caminhos absolutos e relativos: É importante entender a diferença entre caminhos absolutos e relativos
         e como eles são usados pela classe Path.

    5o - Uso de URI: É importante levar em consideração o uso de URI (Uniform Resource Identifier) ao trabalhar
         com a classe Path, pois alguns métodos da classe Path podem aceitar URI como argumentos.

    6o - Métodos da classe Path: É importante entender os vários métodos da classe Path,
         como resolve(), normalize() e relativize(), e como eles funcionam para realizar tarefas específicas.

    7o - Tratamento de exceções: É importante tratar as exceções que podem ser lançadas pela classe Path,
         como InvalidPathException ou SecurityException, para garantir a integridade do código e evitar erros.

    8o - Padrões de projeto: É importante seguir padrões de projeto, como o padrão de projeto Singleton,
         ao trabalhar com a classe Path para garantir a consistência e a manutenibilidade do código.

    9o - Portabilidade: É importante levar em consideração a portabilidade do código ao usar a classe Path,
         pois algumas convenções de caminhos de arquivos podem ser diferentes em sistemas operacionais diferentes.
         É recomendável testar o código em vários sistemas operacionais para garantir que ele funcione


--------> MÉTODOS mais importantes para se trabalhar com os objetos Path:
----> objPath.normalize(); ajusta e deixa o path correto substituindo os caracteres coringa (como ./ por ex)
Obs: Não garante que realmente esta correto o Path "fisíco" serve apenas ao objeto em memória.

Por exemplo, considere o seguinte caminho: "/usr/../var/log/../log/messages". Após a normalização, esse caminho seria simplificado para "/var/log/messages".

    String projectDirectory = "/home/welbert/Documentos/github/MaratonaJava-DevDojo";
    String txtArchive = "../../arquivo.txt";

    Path p1 = Paths.get(projectDirectory, txtArchive); //                            \/ n esta resolvendo
    System.out.println(p1); // /home/welbert/Documentos/github/MaratonaJava-DevDojo/../../arquivo.txt

    System.out.println(p1.normalize()); // /home/welbert/Documentos/arquivo.txt <- resolveu

---> Pontos a se considerar quando se utiliza:
    1o - Redundâncias: O método normalize() remove redundâncias, como ".." e "." no caminho,
         para produzir um caminho mais curto e mais fácil de ler.

    2o - Anomalias: O método normalize() corrige anomalias, como "/./" e "//", para produzir
         um caminho mais preciso e confiável.

    3o - Resultado: O resultado produzido pelo método normalize() é um novo objeto Path que
         representa o caminho normalizado.

    4o - Consequências: É importante ter em mente que o método normalize() pode alterar o caminho original,
         e portanto pode afetar o funcionamento de outros componentes da aplicação que dependem do caminho original.

    5o - Segurança: É importante tomar medidas de segurança apropriadas ao trabalhar com caminhos de arquivos,
         especialmente ao normalizar caminhos que podem conter caracteres especiais ou informações sensíveis.

    6o - Sistemas de arquivos diferentes: É importante levar em consideração as diferenças entre
         sistemas de arquivos ao usar o método normalize(), pois alguns sistemas de arquivos podem
         ter convenções diferentes para caminhos de arquivos e podem produzir resultados diferentes.

    7o - Encoding de caracteres: É importante verificar se o encoding de caracteres usado para o caminho
         é o mesmo usado pelo sistema de arquivos, pois o resultado produzido pelo método normalize()
         pode ser afetado por diferenças de encoding.

    8o - Permissões de arquivos: É importante verificar se o caminho tem as permissões necessárias para
         ser normalizado, pois o método normalize() pode falhar se o usuário não tiver permissão para
         acessar os arquivos no caminho.

    9o - Desempenho: É importante ter em mente que o método normalize() pode ter um impacto no desempenho
         da aplicação, especialmente quando os caminhos são longos ou complexos. Portanto, é importante
         testar cuidadosamente a performance antes de usar o método em produção.

----> objPath.resolve(objPath); Ele toma um caminho relativo como entrada e o combina com o caminho atual para produzir um caminho absoluto.
Por exemplo, suponha que você tenha o seguinte caminho atual: "/var/log" e que você queira combiná-lo com o caminho
relativo "messages". O resultado da combinação seria "/var/log/messages".

Em outras palavras, o método resolve() permite que você combine dois caminhos de forma a produzir um único caminho
absoluto que represente o destino final. É útil quando você precisa criar um caminho completo a partir de um caminho
relativo e de um caminho absoluto de referência.

Obs: Se o caminho ja estiver correto ele desconsidera e retorna sem mudanças e sem erros.
     Ele só resolve apartir de um absoluto para o relativo nunca ao contrário.

    Path currentPath = Paths.get("/home/user/documents");
    Path relativePath = Paths.get("../pictures");

    Path resolvedPath = currentPath.resolve(relativePath);
    System.out.println("Path resolvido: " + resolvedPath);

---> Pontos a se considerar quando se utiliza:
    1o - Finalidade: O método resolve() é usado para combinar dois caminhos de arquivos em um único caminho.
         É importante compreender a finalidade deste método antes de começar a usá-lo em seu código.

    2o - Tipos de caminho: É importante levar em consideração o tipo de caminho que será usado como entrada
         para o método resolve(). O método pode aceitar caminhos absolutos ou relativos, e o resultado
         produzido pode ser diferente dependendo do tipo de caminho usado.

    3o - Caminhos vazios: Se um dos caminhos for vazio, o método resolve() retornará o outro caminho sem
         modificações. É importante ter isso em mente ao usar o método.

    4o - Caminhos relativos: Se um dos caminhos for relativo, o método resolve() irá combiná-lo com o caminho
         absoluto fornecido. É importante ter em mente que o resultado pode ser diferente dependendo da ordem
         em que os caminhos são fornecidos para o método.

    5o - Caminhos absolutos: Se ambos os caminhos forem absolutos, o método resolve() retornará o primeiro
         caminho sem modificações.

    6o - Sistemas de arquivos diferentes: É importante levar em consideração as diferenças entre sistemas de
         arquivos ao usar o método resolve(), pois alguns sistemas de arquivos podem ter convenções diferentes
         para caminhos de arquivos e podem produzir resultados diferentes.

    7o - Encoding de caracteres: É importante verificar se o encoding de caracteres usado para os caminhos
         é o mesmo usado pelo sistema de arquivos, pois o resultado produzido pelo método resolve()
         pode ser afetado por diferenças de encoding.

    8o - Permissões de arquivos: É importante verificar se os caminhos têm as permissões necessárias para
         serem resolvidos, pois o método resolve() pode falhar se o usuário não tiver permissão para
         acessar os arquivos nos caminhos.

    9o - Desempenho: É importante ter em mente que o método resolve() pode ter um impacto no
         desempenho da aplicação, especialmente quando os caminhos s

    10o - Tratamento de exceções: É importante tratar as exceções que podem ser lançadas pelo método resolve(),
          como InvalidPathException ou SecurityException, para garantir a integridade do código e evitar erros.

----> objPath.relativize(); Usado para calcular o caminho relativo entre dois caminhos.
Ele leva dois caminhos como entrada e retorna um caminho relativo que represente a diferença entre eles.
Por exemplo, suponha que você tenha os seguintes caminhos: "/home/user/documents" e "/home/user/pictures".
O resultado da chamada ao método relativize() seria "../pictures".
Esse caminho relativo pode ser usado para navegar do diretório "documents" para o diretório "pictures".

Em outras palavras, o método relativize() permite que você determine o caminho relativo entre dois caminhos absolutos.
É útil quando você precisa determinar como navegar de um diretório para outro.

    Path source = Paths.get("/home/irineu/inemEu"); // origem
    Path target = Paths.get("/home/welbert/dev "); // destino
    System.out.println(source.relativize(target)); // ../../welbert/dev
    System.out.println(target.relativize(source)); // ../../irineu/inemEu

---> Pontos a se considerar quando se utiliza:
    1o - Ambos os caminhos devem ser absolutos ou ambos devem ser relativos.
    Não é possível calcular o caminho relativo entre um caminho absoluto e um caminho relativo.
    Se você tentar fazer isso, uma exceção IllegalArgumentException será lançada.

    2o - O método relativize() retorna um caminho relativo que leva do primeiro caminho para o segundo.
    Se você inverter a ordem dos caminhos, o resultado será diferente.

    3o - O método relativize() não segue links simbólicos. Se você tiver links simbólicos em seu sistema de arquivos,
    o método relativize() os tratará como se fossem arquivos normais.

    4o - O método relativize() retorna um caminho relativo que é válido no sistema de arquivos atual.
    Se você mover os caminhos para outro sistema de arquivos, o caminho relativo retornado pode não ser válido.

    5o - O método relativize() retorna um caminho relativo que usa o separador de diretórios padrão do sistema operacional atual.
    No Windows, o separador de diretórios é "", enquanto no Linux e macOS é "/".
    Tenha isso em mente se você estiver planejando usar o caminho relativo retornado em outra plataforma.

---------------------- // Paths: Classe final utilizada principalmente para gerar uma instância de Path
- Para gerar uma instância de Path utilizamos Paths.get("Caminho", "caminho"...);

    Path filePath = Paths.get(directoriesPath.toString(),"fileTest.txt");
    if (Files.notExists(filePath)) {
        Path filePathCreated = Files.createFile(filePath);
        System.out.println(filePathCreated);
    }

---> Pontos a se considerar quando se utiliza:
    1o - Mesmos pontos levantados em Path.

    2o - Métodos da classe Paths: É importante entender os vários métodos da classe Paths,
         como get(), of() e getFileSystem(), e como eles funcionam para realizar tarefas específicas.

    3o - Tratamento de exceções: Mesmos pontos levantados em Path.

    4o - Padrões de projeto: É importante seguir padrões de projeto, como o padrão de projeto Factory,
         ao trabalhar com a classe Paths para garantir a consistência e a manutenibilidade do código.

    5o - Portabilidade: Mesmos pontos levantados em Path.


---------------------- // Files: Classe 100% Estática ou seja ela é uma classe Utilitária,
Contendo todas as operações de File nela, ou seja a criação, escrita e etc em arquivos.
- Serve como uma Fabrica aonde passamos os paths e utilizamos os métodos com as operações estáticas desejadas.

    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
    Files.createFile(filePath);
    Files.createDirectories(directoriesPath); // aqui passamos um Path que representa os diretórios e subdiretórios.
    Files.createDirectory(directoryPath); // equivalente anterior porém para criar um single diretório.

---> Pontos a se considerar quando se utiliza:
    1o - Permissões de arquivo: é importante lembrar que a classe Files fornece suporte para
         verificar e modificar as permissões de arquivo do sistema operacional subjacente.

    2o - Manipulação de arquivos: a classe Files fornece vários métodos para
         criar, ler, escrever, copiar e mover arquivos. É importante verificar
         se o arquivo que você deseja manipular existe antes de tentar realizar
         qualquer operação sobre ele.

    3o - Lidar com erros: alguns métodos da classe Files podem gerar exceções,
         como FileNotFoundException ou IOException. É importante capturar e
         lidar com essas exceções de maneira adequada em seu código.

    4o - Atributos de arquivo: a classe Files fornece suporte para acessar atributos de arquivo,
         como tamanho, data de modificação, proprietário, entre outros. É importante verificar
         se o sistema operacional subjacente suporta esses atributos antes de tentar acessá-los.

    5o - WatchService: a classe Files fornece suporte para o recurso WatchService, que permite
         a monitoração de alterações em arquivos e pastas. É importante lembrar que esse recurso
         pode ser limitado em alguns sistemas operacionais.

    6o - Trabalhar com streams: a classe Files fornece vários métodos que trabalham com streams,
         o que permite a leitura e escrita de dados em arquivos de forma eficiente.
         É importante compreender o uso de streams em Java antes de usar esses métodos.

    7o - Trabalhar com links simbólicos: a classe Files fornece suporte para criar e manipular
         links simbólicos em sistemas operacionais que os suportam.
         É importante lembrar que nem todos os sistemas operacionais suportam links simbólicos
         e que a criação e manipulação de links simbólicos pode exigir permissões especiais.

    8o - Gerenciamento de recursos: alguns métodos da classe Files trabalham com recursos,
         como arquivos ou streams, que precisam ser fechados após o uso.
         É importante garantir que esses recursos sejam fechados corretamente,
         geralmente usando o bloco try-with-resources.

    9o - Trabalhar com encoding: ao trabalhar com arquivos de texto, é importante compreender
         a codificação de caracteres utilizada pelo arquivo.
         A classe Files fornece suporte para ler e escrever arquivos utilizando diferentes
         codificações de caracteres.

    10o - Performance: ao trabalhar com arquivos grandes ou muitos arquivos,
          é importante considerar as questões de performance.
          A classe Files fornece vários métodos que podem ser otimizados para
          lidar com grandes quantidades de dados.
          Além disso, é importante considerar o impacto de outros recursos do sistema,
          como o armazenamento em disco, na performance.

---------------------- // BasicFileAttributes: Interface mais genérica para representação dos atributos básicos
de um arquivo ou diretório de um sistema de arquivos, utilizada apenas para obter informações como data de criação,
data de última modificação, data de último acesso e se o arquivo é um diretório ou arquivo normal.
(para settar utiliza-se a correspondente BasicFileAttributesView.)
Ou seja utilizamos programação orientada a interface, e deixamos o objeto concreto como responsabilidade do Java
pois a depender do Sistema Operacional o objeto instânciado será especializado para tal.
Por ser a mais genérica, também possuímos Interfaces mais especializadas que extends dela para diferentes S.O's
sendo elas:

- DosFileAttributes (Windows) correspondente para setter: DosFileAttributesView
- PosixFileAttributes (Unix like) correspondente para setter: PosixFileAttributesView
- Dentre outros.

- Por se tratar de uma Interface, é necessário utilizarmos o método estático da classe Files
para obtermos o objeto concreto especializado para o S.O corrente sendo ele:
Files.readAttributes(filePath, BasicFileAttributes.class);
- Podemos observar que o segundo parâmetro se trata de qual objeto concreto queremos,
neste caso utilizamos o mais genérico, mas se quisermos uma instância para Ubuntu poderiamos
passar Files.readAttributes(filePath, PosixFileAttributes.class);

    Path filePath = Paths.get("src/nio/home/welbert/dev/arquivo2_path.txt");
    if (Files.exists(filePath)) {
        BasicFileAttributes basicFileAttributes = Files.readAttributes(filePath, BasicFileAttributes.class);
        FileTime creationTime = basicFileAttributes.creationTime();
        FileTime lastModifiedTime = basicFileAttributes.lastModifiedTime();
        FileTime lastAccessTime = basicFileAttributes.lastAccessTime();
        System.out.println("Data de criação: "+creationTime);// 2023-01-30T16:06:57.120342248Z
        System.out.println("Ultima modificação: "+lastModifiedTime);// 2023-01-30T16:06:57.120342248Z
        System.out.println("Ultimo acesso: "+lastAccessTime); // 2023-02-09T21:56:24.411474014Z
    }

---> Pontos a se considerar quando se utiliza:
    1o - Tipo de atributos: a classe BasicFileAttributes fornece informações básicas sobre um arquivo,
         como a data de criação, última modificação e acesso. É importante compreender os tipos de
         atributos fornecidos pela classe para poder usá-los de maneira efetiva.

    2o - Plataforma dependente: alguns atributos fornecidos pela classe BasicFileAttributes podem ser
         plataforma dependentes. É importante verificar a documentação da classe para saber quais
         atributos são suportados em cada plataforma.

    3o - Exceções: ao trabalhar com atributos de arquivo, é possível que ocorram exceções, como o
         arquivo não existir ou o usuário não ter permissão para acessar o arquivo. É importante
         lidar corretamente com essas exceções.

    4o - Desempenho: ao trabalhar com atributos de arquivo, é importante considerar o impacto no
         desempenho da aplicação. A classe BasicFileAttributes fornece informações sobre arquivos
         de forma eficiente, mas é importante levar em conta o número de arquivos acessados e as
         informações que são realmente necessárias.

    5o - Acesso a atributos avançados: a classe BasicFileAttributes fornece informações básicas sobre
         um arquivo, mas nem sempre é possível acessar atributos mais avançados como informações sobre
         propriedade, permissões, etc. É importante verificar a documentação da classe e da plataforma
         para saber quais atributos adicionais podem ser acessados.

    6o - Compatibilidade com sistemas de arquivos: diferentes sistemas de arquivos podem suportar diferentes
         atributos, e alguns podem não ser suportados de forma nativa pela classe BasicFileAttributes.
         É importante verificar a documentação da classe e da plataforma para saber quais atributos são
         suportados em cada sistema de arquivos.

    7o - Atualização dinâmica: é importante levar em conta que os atributos de arquivo podem mudar dinamicamente,
         por exemplo, ao ser modificado ou movido. Portanto é necessário atualizar a instância do objeto em memória.

    8o - Caches: a classe BasicFileAttributes pode usar caches internos para acelerar o acesso aos atributos.
         É importante levar em conta esse comportamento ao trabalhar com atributos dinâmicos, para garantir
         que as informações retornadas sejam sempre precisas.

    9o - Segurança: ao trabalhar com atributos de arquivo, é importante considerar questões de segurança,
         como a permissão para acessar arquivos confidenciais.

---------------------- // DosFileAttributes: Interface mais especializada para S.O's Windows.
extends de BasicFileAttributes, e também possuí a correspondente DosFileAttributesView para settar as informações.
- Utilizada para obter informações de arquivos ou diretórios com as convenções DOS.

- Não consegui utiliza-la por conta do Ubuntu.

---> Pontos a se considerar quando se utiliza:
    1o - Sistemas de arquivos suportados: A classe DosFileAttributes é específica para sistemas de arquivos
         baseados no formato DOS, como o FAT e o NTFS. Se você estiver trabalhando com outro tipo de sistema
         de arquivos, como o UNIX ou o MacOS, deve usar outra classe de atributos de arquivo, como PosixFileAttributes.

    2o - Atributos disponíveis: A classe DosFileAttributes fornece acesso a atributos específicos do formato DOS,
         como o atributo "arquivo oculto" e o atributo "somente leitura". Se você precisar de acesso a outros
         tipos de atributos de arquivo, deve usar outra classe de atributos de arquivo.

    3o - Modificação de atributos: É possível modificar os atributos de um arquivo usando a classe DosFileAttributes,
         mas é importante ter cuidado ao fazer isso, pois essas modificações podem afetar a funcionalidade de outros
         programas ou sistemas que estejam usando o arquivo. Além disso, certos atributos, como o atributo
         "somente leitura", podem ser ignorados pelo sistema de arquivos ou pelo sistema operacional.

    4o - Sincronização de arquivos: É importante levar em consideração como a classe DosFileAttributes se integra
         com as operações de sincronização de arquivos em seu sistema. Por exemplo, se você estiver modificando
         atributos de arquivos em um sistema distribuído, é importante garantir que as modificações sejam
         sincronizadas adequadamente em todas as instâncias do arquivo.


---------------------- // PosixFileAttributes: Interface mais especializada para S.O's Unix like (Linux e MacOS).
extends de BasicFileAttributes, e também possuí a correspondente PosixFileAttributesView para settar as informações.
- Utilizada para obter informações de arquivos ou diretórios com as convenções Unix Like.

    PosixFileAttributes posixFileAttributes = Files.readAttributes(filePath, PosixFileAttributes.class);
    System.out.println(posixFileAttributes.permissions());

    // Define permissões como rwxrw-rw-
    Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rw-r--r--");
    Files.setAttribute(filePath, "posix:permissions", permissions);

    // Verifica se as permissões foram aplicadas corretamente
    Set<PosixFilePermission> newPermissions =
            (Set<PosixFilePermission>) Files.getAttribute(filePath, "posix:permissions");
    System.out.println(PosixFilePermissions.toString(newPermissions));


---> Pontos a se considerar quando se utiliza:
    1o - Compatibilidade: A classe PosixFileAttributes fornece acesso a atributos específicos de sistemas de arquivos
         POSIX, como o proprietário do arquivo, o grupo proprietário e as permissões de acesso. No entanto, esses
         atributos só estarão disponíveis em sistemas operacionais compatíveis com POSIX, como Linux e macOS.

    2o - Métodos disponíveis: A classe PosixFileAttributes fornece vários métodos úteis para acessar informações
         sobre o proprietário do arquivo, o grupo proprietário e as permissões de acesso. Por exemplo, você pode
         usar o método owner() para obter o proprietário do arquivo e o método permissions() para obter as
         permissões de acesso.

    3o - Atualização de atributos: Se você precisar atualizar os atributos do arquivo, como as permissões de acesso,
         é necessário usar outras classes, como a classe Files, para fazer isso.

    4o - Limitações: Ao trabalhar com a classe PosixFileAttributes, é importante lembrar que essa classe fornece
         acesso apenas a atributos específicos de sistemas de arquivos POSIX.

    5o - Permissões: A classe PosixFileAttributes oferece acesso às permissões de um arquivo no sistema operacional.
         É importante ter cuidado ao modificar as permissões de um arquivo, pois isso pode afetar a segurança do sistema.

    6o - Proprietário e grupo: A classe PosixFileAttributes permite o acesso ao proprietário e ao grupo de um arquivo.
         É importante ter cuidado ao modificar o proprietário ou o grupo de um arquivo, pois isso pode afetar a segurança do sistema.

    7o - Performance: O acesso aos atributos de um arquivo pode ser custoso em termos de desempenho, especialmente
         em sistemas com muitos arquivos. É importante considerar esta questão ao desenvolver aplicações que
         trabalham com muitos arquivos.


---------------------- // DirectoryStream: Classe utilizada para iterar level 1 da árvore em diretórios.
Para iteração ALL recursiva para todos os nós abaixo da árvore de diretórios utilizamos SimpleFileVisitor

A classe DirectoryStream do Java é usada para representar uma sequência de arquivos em um diretório.
Ela permite que você faça o loop sobre os arquivos de um diretório de forma fácil e eficiente.
Além disso, a classe DirectoryStream fornece suporte para filtrar arquivos com base em diferentes critérios,
como nome do arquivo, tamanho do arquivo, data de modificação e atributos do arquivo.

Por exemplo, você pode usar a classe DirectoryStream para listar todos os arquivos de um diretório que
tenham uma determinada extensão ou que tenham sido modificados em uma determinada data.
A classe DirectoryStream é uma ótima opção para tarefas que exigem a manipulação de arquivos em um diretório,
pois é muito mais eficiente do que fazer o loop sobre os arquivos manualmente.

- O método newDirectoryStream() da classe Files é usado para criar uma instância de DirectoryStream.

Exemplo: Todos os arquivos que acabam com ".java" do diretório src/nio (level 1 da arvore, sem recursividade).

    Path filePath = Paths.get("src/nio");
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(filePath, path ->
                            path.toString().endsWith(".java"))) { // ou ao invés de utilizar lambda, passar glob "*.java"
        for (Path path : directoryStream) {
            System.out.println(path);
        }
    } catch (IOException ex) {
        ex.printStackTrace();
    }
- Obs: Como ela implementa a Clouseble ou seja devemos fechar após o uso, utilizamos try-with-resources.

---> Pontos a se considerar quando se utiliza:
    1o - O objeto DirectoryStream representa um fluxo de arquivos em um diretório.

    2o - Para iterar sobre os arquivos de um diretório, é necessário criar uma instância da classe DirectoryStream.

    3o - A classe DirectoryStream implementa a interface AutoCloseable, o que significa que é necessário fechá-la
         explicitamente após o uso. (Porisso utilizamos try-with-resources).

    4o - A classe DirectoryStream suporta filtros para listar somente arquivos com determinadas características,
         como extensão ou prefixo.

    5o - A classe DirectoryStream permite a iteração apenas em um diretório. Não é possível acessar seu conteúdo
         recursivamente. (Para isto temos a SimpleFileVisitor).

    6o - A classe DirectoryStream é uma alternativa mais eficiente ao uso de File.listFiles() para listar arquivos
         em um diretório, pois permite usar filtros e evita carregar todos os arquivos em memória de uma só vez.

    7o - A classe DirectoryStream é usada para listar o conteúdo de um diretório. Ela fornece uma maneira de
         obter o conteúdo de um diretório de forma lazily, o que significa que os arquivos não são carregados
         em memória até que sejam acessados.

    8o - A classe DirectoryStream não oferece suporte para a adição ou remoção de arquivos do diretório.
         Se precisar fazer isso, você deve usar outras classes do Java, como Files ou Path.

    9o - A classe DirectoryStream é apropriada para operações de leitura apenas. Se precisar de acesso
         de escrita ao conteúdo de um diretório, você deve usar outra classe.

    10o - Ao usar a classe DirectoryStream, é importante sempre fechar o fluxo depois de ter terminado de
          ler o conteúdo do diretório, pois isso libera recursos do sistema. Isso pode ser feito com o
          método close() da classe DirectoryStream ou com o uso de uma cláusula try-with-resources.


---------------------- // SimpleFileVisitor: Classe utilizada para iterar level ALL da árvore de diretórios.
Ou seja, ao contrario da classe anterior () esta trabalha de forma recursiva, para todos os nós abaixo da arvore
de diretórios.

A classe SimpleFileVisitor é uma classe abstrata fornecida no Java que implementa a interface FileVisitor.
A classe FileVisitor é usada para percorrer uma hierarquia de diretórios e arquivos, sendo chamada para
cada diretório ou arquivo encontrado durante a travessia.

A classe SimpleFileVisitor fornece uma implementação simples dos métodos da interface FileVisitor,
tornando mais fácil para os desenvolvedores personalizar a lógica de processamento de arquivos durante a travessia.

- Os métodos da interface FileVisitor incluem:

    - preVisitDirectory(): é chamado antes de visitar um diretório.
    - visitFile(): é chamado para cada arquivo encontrado durante a travessia.
    - visitFileFailed(): é chamado quando a visita a um arquivo falha.
    - postVisitDirectory(): é chamado após visitar um diretório.

    - O método preVisitDirectory() é chamado antes de visitar os arquivos no diretório especificado.
      Ele pode ser usado para executar tarefas específicas do diretório, como permissões de leitura ou gravação.
    - O método visitFile() é chamado para cada arquivo no diretório especificado.
      Ele pode ser usado para executar tarefas específicas do arquivo, como cálculos de tamanho ou cópia de arquivos.
    - O método visitFileFailed() é chamado quando ocorre um erro ao tentar visitar um arquivo.
      Ele pode ser usado para manipular exceções, como quando o arquivo não pode ser lido ou o usuário não tem
      permissão para acessá-lo.
    - O método postVisitDirectory() é chamado depois de visitar todos os arquivos no diretório especificado.
      Ele pode ser usado para executar tarefas específicas de diretório, como atualizar as permissões após a visita.

- As flags/enumeradores utilizadas para retorno dos métodos anteriores e seu comportamento:

    - FileVisitResult.CONTINUE: Define que ira continuar a interação, ou seja próximo Path.
    - FileVisitResult.TERMINATE: Define que encontrou o Path desejado e Finaliza.
    - FileVisitResult.SKIP_SUBTREE: Define que é para sair da subpasta corrente.
    - FileVisitResult.SKIP_SIBLINGS Continua interação pulando quem está no mesmo nível da arvore.

Ao estender a classe SimpleFileVisitor e sobrescrever os métodos desejados, os desenvolvedores podem personalizar
o comportamento da classe de acordo com as necessidades de sua aplicação. Por exemplo, é possível implementar
um método visitFile() para processar cada arquivo encontrado durante a travessia e fazer alguma operação,
como a cópia de arquivos para outra localização ou a criação de um índice de arquivos.

Resumindo, a classe SimpleFileVisitor é uma ferramenta útil para desenvolvedores que precisam percorrer
arquivos e diretórios em suas aplicações Java e realizar alguma ação específica em cada arquivo ou diretório.

- É importante garantir que a classe SimpleFileVisitor seja usada em conjunto com o método Files.walkFileTree(),
que inicia a visita. O método Files.walkFileTree() recebe um Path para o diretório raiz a ser visitado e uma
instância de FileVisitor.

    class ListAllFiles extends SimpleFileVisitor<Path> {
        // Atalho para sobre-escrever métodos: CTRL + O

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            if (file.toString().endsWith(".java")) {
                // printa todos os arquivos .java encontrados na iteração.

                // Função equivalente ao comando em bash:
                // find /home/welbert/Documentos/github/MaratonaJava-DevDojo -name "*.java" -type f;

                // Ou filtra a saída para deixar apenas o nome do arquivo, eliminando o caminho completo:
                // find /home/welbert/Documentos/github/MaratonaJava-DevDojo -name "*.java" -type f -exec basename {} \;

                System.out.println(file.getFileName());

                // salvando em arquivo .txt a saída ("*.java") e comparando com o equivalente em bash
                // e depois realiza a comparação dos dois arquivos para validar se ambas correspondem
                // Saída gerada pelo Java == Saída gerada pelo Bash
                Path outputPath = Paths.get("src/nio/aula154SimpleFileVisitorSaida.txt");
                Files.write(outputPath, (file.getFileName().toString()+"\n").getBytes(), StandardOpenOption.APPEND);

            }

            return FileVisitResult.CONTINUE; // continua iteração até o final da arvore. ALL Itens
        }
    }

---> Pontos a se considerar quando se utiliza:
    1o - A classe SimpleFileVisitor é uma classe abstrata que implementa a interface FileVisitor.
         Isso significa que, para usá-la, você deve estender a classe e implementar os métodos que você deseja.

    2o - A classe SimpleFileVisitor é uma implementação básica da interface FileVisitor e oferece métodos
         padrão para lidar com visitas de arquivos e diretórios.

    3o - A classe SimpleFileVisitor fornece quatro métodos que você pode implementar para lidar com
         diferentes eventos: preVisitDirectory, visitFile, visitFileFailed e postVisitDirectory.

    4o - O método preVisitDirectory é chamado antes que o conteúdo de um diretório seja visitado.
         Ele recebe um objeto Path que representa o diretório que será visitado e um objeto
         BasicFileAttributes que contém informações sobre o diretório.

    5o - O método visitFile é chamado para cada arquivo no diretório visitado.
         Ele recebe um objeto Path que representa o arquivo e um objeto BasicFileAttributes
         que contém informações sobre o arquivo.

    6o - O método visitFileFailed é chamado se ocorrer um erro ao visitar um arquivo.
         Ele recebe um objeto Path que representa o arquivo que não pôde ser visitado e
         uma exceção que descreve o erro.

    7o - O método postVisitDirectory é chamado após todo o conteúdo de um diretório ser visitado.
         Ele recebe um objeto Path que representa o diretório que foi visitado e uma exceção,
         caso tenha ocorrido um erro durante a visita.

    8o - A classe SimpleFileVisitor é frequentemente usada em conjunto com as classes Files e Paths
         para percorrer diretórios e realizar ações em arquivos.

    9o - A classe SimpleFileVisitor é altamente customizável, permitindo que você personalize a
         maneira como seu código lida com a visita de diretórios e arquivos.

    10o - Ao estender a classe SimpleFileVisitor, lembre-se de que você só precisa implementar
          os métodos que deseja usar. Se você não precisar lidar com um determinado evento,
          pode deixar o método vazio em sua implementação.


---------------------- // PathMatcher: Em resumo, a classe PathMatcher é usada para comparar um Path com um
padrão de correspondência especificado e é usada em conjunto com a classe FileSystem para permitir a busca
de arquivos em um sistema de arquivos com base em um padrão de correspondência.

A classe PathMatcher no Java é usada para comparar um Path com um padrão de correspondência especificado.
Ela é usada em conjunto com a classe FileSystem para permitir a busca de arquivos em um sistema de arquivos
com base em um padrão de correspondência.

A classe PathMatcher é útil em aplicativos que precisam procurar arquivos em um sistema de arquivos com
base em um padrão de nome de arquivo ou diretório. Por exemplo, um aplicativo de busca de arquivos pode
usar a classe PathMatcher para procurar arquivos que correspondam a um padrão de nome de arquivo ou
diretório especificado pelo usuário.

Para usar a classe PathMatcher, você deve primeiro criar uma instância de um FileSystem e, em seguida,
criar um objeto PathMatcher usando o método FileSystem.getPathMatcher(). O método PathMatcher.matches()
é usado para comparar um Path com um padrão de correspondência especificado. O método retorna true se
o Path corresponder ao padrão de correspondência e false caso contrário.

    public class TextFileFinder extends SimpleFileVisitor<Path> {

        private PathMatcher matcher;

        public TextFileFinder() {
            // cria um padrão de correspondência para encontrar arquivos de texto
            this.matcher = FileSystems.getDefault().getPathMatcher("glob:**/*.txt");
        }

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
            if (matcher.matches(file)) {
                System.out.println("Arquivo de texto encontrado: " + file);
            }
            return FileVisitResult.CONTINUE;
        }

        public static void main(String[] args) throws IOException {
            // inicia a busca por arquivos de texto no diretório "C:\exemplo"
            Path startDir = Paths.get("C:\\exemplo");
            TextFileFinder finder = new TextFileFinder();
            Files.walkFileTree(startDir, finder);
        }
    }

