-- Data 06/01/2023 até 00/00/2023 (Estudos feitos em .Java e agora documentado)
-- link:
-- Mais informações sobre nio (new IO): https://docs.oracle.com/javase/tutorial/essential/io/legacy.html

Intermediário: Mais especifico no Java


- Introdução: Nova forma de se trabalhar com o IO, mais otimizado e maior coerência entre classes.


[Class File] <=====================================> [Interface Path] -> substitui a classe File por Path
     /\                                                     /\
     ||                                                     ||
     ||                                                [Class Paths] -> Utilizada para dar origem a uma interface Path
     ||
[Class Util Files] -> Todos os métodos de File foram passados para Files (Estáticos)

// Classes aboradads neste package:
// Path (Substitui a class File)
// Paths (Utilizada principalmente para instânciar um Path)
// Files (100% Estática ou seja Utils com todas as operações de File) criar, verificar se existe e etc..
// BasicFileAttributes (Utilizada para manipulações nos atributos de um Path/Arquivo).
    // Correspondente para settar valores: BasicFileAttributesView
    // POLIMORFISMO para S.O's:
        // DosFileAttributes (Winodows) Também possue o correspondente DosFileAttributesView para settar.
        // PosixFileAttributes (Unix like) Também possue o correspondente PosixFileAttributesView para settar.
// DirectoryStream (Classe mais básica para interar sobre level 1 da arvore de diretórios).
// SimpleFileVisitor (Classe que ao EXTENDS podemos interar recursivamente (ALL) abaixo da arvore de diretórios.
// PathMatcher (Classe utilizada neste contexto para filtrar por um padrão (globExpression)) e selecionar arquivos especificos.
// ZipOutputStream (Classe utilizada para apartir de uma lista de Paths zipar esses arquivos e salvar em outro Path).


---------------------- // Path: Interface devido ao POLIMORFISMO de S.O's compatíveis com o Java
Ou seja, utilizamos como variável de referência esse genérico para apartir da classe Paths pegar uma instância
correta de acordo com o S.O e utilizamos desta programação orientada a interface.
- Substitui a antiga classe File (Ou seja é uma representação do arquivo em Obj na memória).
- Pegamos uma instância com o método estático Paths.get("Caminho");
    - Por ser um varargs (...) podemos passar pasta a pasta do caminho utilizando "," Paths.get("C:", "pamonha", "arq.txt");

Extends: Comparable<Path>, Iterable<Path>, Watchable
ou seja, podemos utilizar o método compareTo() e etc...

- Obs: Não é garantido que o arquivo realmente existe, ou seja não é garantido que o Path é válido!
- Para saber se é válido devemos utilizar o método estático Files.notExists(filePath);
- E para criar utilizamos Files.createFile(filePath);

- Com um objeto dele é possível obter todas informações referênte ao arquivo em sí
  como data de criação, modificação, diretório pai e etc...

---> Pontos a se considerar quando se utiliza:
    1o - Sistema operacional: É importante levar em consideração o sistema operacional em que
         o código será executado, pois algumas convenções de caminhos de arquivos podem ser
         diferentes em sistemas operacionais diferentes.

    2o - Permissões de arquivos: É importante verificar as permissões de arquivos e diretórios
         ao trabalhar com a classe Path, para garantir que o código tenha acesso aos arquivos necessários.

    3o - Nomes de arquivos e diretórios: É importante ter cuidado ao especificar nomes de arquivos e diretórios,
         pois alguns nomes podem não ser válidos em alguns sistemas operacionais.

    4o - Caminhos absolutos e relativos: É importante entender a diferença entre caminhos absolutos e relativos
         e como eles são usados pela classe Path.

    5o - Uso de URI: É importante levar em consideração o uso de URI (Uniform Resource Identifier) ao trabalhar
         com a classe Path, pois alguns métodos da classe Path podem aceitar URI como argumentos.

    6o - Métodos da classe Path: É importante entender os vários métodos da classe Path,
         como resolve(), normalize() e relativize(), e como eles funcionam para realizar tarefas específicas.

    7o - Tratamento de exceções: É importante tratar as exceções que podem ser lançadas pela classe Path,
         como InvalidPathException ou SecurityException, para garantir a integridade do código e evitar erros.

    8o - Padrões de projeto: É importante seguir padrões de projeto, como o padrão de projeto Singleton,
         ao trabalhar com a classe Path para garantir a consistência e a manutenibilidade do código.

    9o - Portabilidade: É importante levar em consideração a portabilidade do código ao usar a classe Path,
         pois algumas convenções de caminhos de arquivos podem ser diferentes em sistemas operacionais diferentes.
         É recomendável testar o código em vários sistemas operacionais para garantir que ele funcione


--------> MÉTODOS mais importantes para se trabalhar com os objetos Path:
----> objPath.normalize(); ajusta e deixa o path correto substituindo os caracteres coringa (como ./ por ex)
Obs: Não garante que realmente esta correto o Path "fisíco" serve apenas ao objeto em memória.

Por exemplo, considere o seguinte caminho: "/usr/../var/log/../log/messages". Após a normalização, esse caminho seria simplificado para "/var/log/messages".

    String projectDirectory = "/home/welbert/Documentos/github/MaratonaJava-DevDojo";
    String txtArchive = "../../arquivo.txt";

    Path p1 = Paths.get(projectDirectory, txtArchive); //                            \/ n esta resolvendo
    System.out.println(p1); // /home/welbert/Documentos/github/MaratonaJava-DevDojo/../../arquivo.txt

    System.out.println(p1.normalize()); // /home/welbert/Documentos/arquivo.txt <- resolveu

---> Pontos a se considerar quando se utiliza:
    1o - Redundâncias: O método normalize() remove redundâncias, como ".." e "." no caminho,
         para produzir um caminho mais curto e mais fácil de ler.

    2o - Anomalias: O método normalize() corrige anomalias, como "/./" e "//", para produzir
         um caminho mais preciso e confiável.

    3o - Resultado: O resultado produzido pelo método normalize() é um novo objeto Path que
         representa o caminho normalizado.

    4o - Consequências: É importante ter em mente que o método normalize() pode alterar o caminho original,
         e portanto pode afetar o funcionamento de outros componentes da aplicação que dependem do caminho original.

    5o - Segurança: É importante tomar medidas de segurança apropriadas ao trabalhar com caminhos de arquivos,
         especialmente ao normalizar caminhos que podem conter caracteres especiais ou informações sensíveis.

    6o - Sistemas de arquivos diferentes: É importante levar em consideração as diferenças entre
         sistemas de arquivos ao usar o método normalize(), pois alguns sistemas de arquivos podem
         ter convenções diferentes para caminhos de arquivos e podem produzir resultados diferentes.

    7o - Encoding de caracteres: É importante verificar se o encoding de caracteres usado para o caminho
         é o mesmo usado pelo sistema de arquivos, pois o resultado produzido pelo método normalize()
         pode ser afetado por diferenças de encoding.

    8o - Permissões de arquivos: É importante verificar se o caminho tem as permissões necessárias para
         ser normalizado, pois o método normalize() pode falhar se o usuário não tiver permissão para
         acessar os arquivos no caminho.

    9o - Desempenho: É importante ter em mente que o método normalize() pode ter um impacto no desempenho
         da aplicação, especialmente quando os caminhos são longos ou complexos. Portanto, é importante
         testar cuidadosamente a performance antes de usar o método em produção.

----> objPath.resolve(objPath); Ele toma um caminho relativo como entrada e o combina com o caminho atual para produzir um caminho absoluto.
Por exemplo, suponha que você tenha o seguinte caminho atual: "/var/log" e que você queira combiná-lo com o caminho
relativo "messages". O resultado da combinação seria "/var/log/messages".

Em outras palavras, o método resolve() permite que você combine dois caminhos de forma a produzir um único caminho
absoluto que represente o destino final. É útil quando você precisa criar um caminho completo a partir de um caminho
relativo e de um caminho absoluto de referência.

Obs: Se o caminho ja estiver correto ele desconsidera e retorna sem mudanças e sem erros.
     Ele só resolve apartir de um absoluto para o relativo nunca ao contrário.

    Path currentPath = Paths.get("/home/user/documents");
    Path relativePath = Paths.get("../pictures");

    Path resolvedPath = currentPath.resolve(relativePath);
    System.out.println("Path resolvido: " + resolvedPath);

---> Pontos a se considerar quando se utiliza:
    1o - Finalidade: O método resolve() é usado para combinar dois caminhos de arquivos em um único caminho.
         É importante compreender a finalidade deste método antes de começar a usá-lo em seu código.

    2o - Tipos de caminho: É importante levar em consideração o tipo de caminho que será usado como entrada
         para o método resolve(). O método pode aceitar caminhos absolutos ou relativos, e o resultado
         produzido pode ser diferente dependendo do tipo de caminho usado.

    3o - Caminhos vazios: Se um dos caminhos for vazio, o método resolve() retornará o outro caminho sem
         modificações. É importante ter isso em mente ao usar o método.

    4o - Caminhos relativos: Se um dos caminhos for relativo, o método resolve() irá combiná-lo com o caminho
         absoluto fornecido. É importante ter em mente que o resultado pode ser diferente dependendo da ordem
         em que os caminhos são fornecidos para o método.

    5o - Caminhos absolutos: Se ambos os caminhos forem absolutos, o método resolve() retornará o primeiro
         caminho sem modificações.

    6o - Sistemas de arquivos diferentes: É importante levar em consideração as diferenças entre sistemas de
         arquivos ao usar o método resolve(), pois alguns sistemas de arquivos podem ter convenções diferentes
         para caminhos de arquivos e podem produzir resultados diferentes.

    7o - Encoding de caracteres: É importante verificar se o encoding de caracteres usado para os caminhos
         é o mesmo usado pelo sistema de arquivos, pois o resultado produzido pelo método resolve()
         pode ser afetado por diferenças de encoding.

    8o - Permissões de arquivos: É importante verificar se os caminhos têm as permissões necessárias para
         serem resolvidos, pois o método resolve() pode falhar se o usuário não tiver permissão para
         acessar os arquivos nos caminhos.

    9o - Desempenho: É importante ter em mente que o método resolve() pode ter um impacto no
         desempenho da aplicação, especialmente quando os caminhos s

    10o - Tratamento de exceções: É importante tratar as exceções que podem ser lançadas pelo método resolve(),
          como InvalidPathException ou SecurityException, para garantir a integridade do código e evitar erros.

----> objPath.relativize(); Usado para calcular o caminho relativo entre dois caminhos.
Ele leva dois caminhos como entrada e retorna um caminho relativo que represente a diferença entre eles.
Por exemplo, suponha que você tenha os seguintes caminhos: "/home/user/documents" e "/home/user/pictures".
O resultado da chamada ao método relativize() seria "../pictures".
Esse caminho relativo pode ser usado para navegar do diretório "documents" para o diretório "pictures".

Em outras palavras, o método relativize() permite que você determine o caminho relativo entre dois caminhos absolutos.
É útil quando você precisa determinar como navegar de um diretório para outro.

    Path source = Paths.get("/home/irineu/inemEu"); // origem
    Path target = Paths.get("/home/welbert/dev "); // destino
    System.out.println(source.relativize(target)); // ../../welbert/dev
    System.out.println(target.relativize(source)); // ../../irineu/inemEu

---> Pontos a se considerar quando se utiliza:
    1o - Ambos os caminhos devem ser absolutos ou ambos devem ser relativos.
    Não é possível calcular o caminho relativo entre um caminho absoluto e um caminho relativo.
    Se você tentar fazer isso, uma exceção IllegalArgumentException será lançada.

    2o - O método relativize() retorna um caminho relativo que leva do primeiro caminho para o segundo.
    Se você inverter a ordem dos caminhos, o resultado será diferente.

    3o - O método relativize() não segue links simbólicos. Se você tiver links simbólicos em seu sistema de arquivos,
    o método relativize() os tratará como se fossem arquivos normais.

    4o - O método relativize() retorna um caminho relativo que é válido no sistema de arquivos atual.
    Se você mover os caminhos para outro sistema de arquivos, o caminho relativo retornado pode não ser válido.

    5o - O método relativize() retorna um caminho relativo que usa o separador de diretórios padrão do sistema operacional atual.
    No Windows, o separador de diretórios é "", enquanto no Linux e macOS é "/".
    Tenha isso em mente se você estiver planejando usar o caminho relativo retornado em outra plataforma.

---------------------- // Paths: Classe final utilizada principalmente para gerar uma instância de Path
- Para gerar uma instância de Path utilizamos Paths.get("Caminho", "caminho"...);

    Path filePath = Paths.get(directoriesPath.toString(),"fileTest.txt");
    if (Files.notExists(filePath)) {
        Path filePathCreated = Files.createFile(filePath);
        System.out.println(filePathCreated);
    }

---> Pontos a se considerar quando se utiliza:
    1o - Mesmos pontos levantados em Path.

    2o - Métodos da classe Paths: É importante entender os vários métodos da classe Paths,
         como get(), of() e getFileSystem(), e como eles funcionam para realizar tarefas específicas.

    3o - Tratamento de exceções: Mesmos pontos levantados em Path.

    4o - Padrões de projeto: É importante seguir padrões de projeto, como o padrão de projeto Factory,
         ao trabalhar com a classe Paths para garantir a consistência e a manutenibilidade do código.

    5o - Portabilidade: Mesmos pontos levantados em Path.
