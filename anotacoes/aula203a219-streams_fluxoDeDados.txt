-- Data de Documentação: - (Estudos feitos em Java e agora documentado)
-- Data de Estudos: -

-- link: -

Intermediário: Mais específico no Java

---> API Streams introduzido no Java 8 (Fluxo de Dados, com operações prontas):

A API Streams em Java é uma parte importante da biblioteca de coleções Java 8
e superiores. A API Streams é utilizada para processar coleções de objetos, tais
como listas, conjuntos, mapas, arrays, e assim por diante, de uma forma mais
concisa e eficiente.

Os Streams permitem a execução de operações em um conjunto de dados sem a
necessidade de alterar a coleção original. Eles oferecem uma série de recursos,
como filtragem, mapeamento, classificação, operações de redução e muito mais.

Em resumo, a API Streams em Java é uma ferramenta poderosa para processar e
manipular coleções de dados de uma maneira mais eficiente e expressiva,
permitindo uma maior flexibilidade e desempenho na programação.

---> Vantagens de se utilizar:

    - Fácil leitura e manutenção do código devido à sua expressividade.
    - Capacidade de processar coleções grandes de dados em paralelo.
    - Maior flexibilidade na execução de operações em coleções, sem a
    necessidade de criar loops explícitos.

---> Utilidades e aplicações:

    - Processamento de coleções de dados em aplicativos web e mobile.
    - Análise de dados em aplicações de ciência de dados.
    - Cálculos financeiros e matemáticos em aplicações financeiras.
    - Transformação e manipulação de dados em processos de ETL
    (Extract, Transform, Load).


---> Métodos mais Uteis da API Streams:

- filter(Predicate<T> predicate): retorna um Stream contendo apenas os elementos
da coleção original que correspondem ao predicado especificado.
Este método é útil para filtrar elementos de uma coleção com base em um critério
específico.

- map(Function<T, R> mapper): retorna um Stream contendo os resultados da aplicação
da função especificada a cada elemento da coleção original.
Este método é útil para transformar elementos de uma coleção em outros elementos
de um tipo diferente.

- flatMap(Function<T, Stream<R>> mapper): retorna um Stream contendo todos os
elementos resultantes da aplicação da função especificada a cada elemento da
coleção original, concatenados em um único Stream.
Este método é útil para transformar elementos de uma coleção em múltiplos
elementos de um tipo diferente.

- sorted(): retorna um Stream contendo os elementos da coleção original em ordem
natural (ascendente).
Este método é útil para classificar elementos de uma coleção em uma ordem específica.

- distinct(): retorna um Stream contendo apenas os elementos distintos da coleção
original. Este método é útil para remover elementos duplicados de uma coleção.

- reduce(T identity, BinaryOperator<T> accumulator): combina os elementos da coleção
original usando o operador binário especificado, começando com o elemento inicial
especificado.
Este método é útil para reduzir os elementos de uma coleção em um único valor.

- collect(Collector<T, A, R> collector): coleta os elementos da coleção original
em um resultado especificado pelo coletor especificado.
Este método é útil para coletar elementos de uma coleção em uma estrutura de dados
específica, como uma lista ou um mapa.

- forEach(Consumer<T> action): executa a ação especificada em cada elemento da
coleção original.
Este método é útil para executar uma ação em cada elemento de uma coleção sem
modificar a coleção em si.

- peek(Consumer<T> action): retorna um Stream contendo os mesmos elementos da
coleção original, mas executa a ação especificada em cada elemento do Stream.
Este método é útil para depuração e logging, pois permite executar uma ação em
cada elemento de uma coleção sem modificar o Stream em si.

- anyMatch(Predicate<T> predicate): retorna um valor booleano indicando se algum
elemento da coleção original corresponde ao predicado especificado.
Este método é útil para verificar se pelo menos um elemento de uma coleção
corresponde a um critério específico.

- allMatch(Predicate<T> predicate): retorna um valor booleano indicando se todos
os elementos da coleção original correspondem ao predicado especificado.
Este método é útil para verificar se todos os elementos de uma coleção correspondem
a um critério específico.

- noneMatch(Predicate<T> predicate): retorna um valor booleano indicando se nenhum
elemento da coleção original corresponde ao predicado especificado.
Este método é útil para verificar se nenhum elemento de uma coleção corresponde a
um critério específico.

- skip(long n): retorna um Stream contendo todos os elementos da coleção original,
exceto os primeiros n elementos.
Este método é útil para pular os primeiros elementos de uma coleção.

- limit(long maxSize): retorna um Stream contendo os primeiros maxSize elementos
da coleção original.
Este método é útil para limitar o número de elementos de uma coleção que são
processados.

- toArray(): retorna um array contendo todos os elementos do Stream.
Este método é útil para converter um Stream em um array.


-------------------------------------------------------------------------------
---> `flatMap()` Utilizado para "Achatar" a operação map, combinando (join) as
Streams do fluxo em apenas uma Stream no retorno.

O método flatMap() da classe Stream é um método intermediário que é usado para
transformar uma Stream de objetos em outra Stream de objetos, com base em uma
função fornecida como argumento.
O objetivo do método flatMap() é permitir a manipulação e transformação de objetos
em uma Stream em um único passo, sem a necessidade de operações adicionais.

Ele é particularmente útil quando se trabalha com dados que possuem uma estrutura
hierárquica, como listas aninhadas ou mapeamentos de valores.

A função passada como argumento do método flatMap() é aplicada a cada elemento da
Stream, que é então transformado em uma nova Stream de objetos.
As Streams resultantes são então combinadas em uma única Stream de saída.

Em resumo, o método flatMap() da classe Stream é uma ferramenta útil para transformar
objetos em uma Stream em outros objetos em uma nova Stream em um único passo.
Ele é particularmente útil ao trabalhar com dados hierárquicos e pode ajudar a
simplificar operações de transformação e filtragem.


---> O que ele faz em low level para isso ser possivel?

O método flatMap() da classe Stream é implementado através de iteração e manipulação
de ponteiros.

Ao chamar o método flatMap(), a Stream de entrada é iterada e para cada elemento, a
função fornecida como argumento é aplicada.
Essa função retorna uma nova Stream de objetos que é adicionada a uma nova Stream
resultante. A iteração continua até que todos os elementos da Stream de entrada
tenham sido processados.

Internamente, o método flatMap() é implementado por meio de uma estrutura de loop,
que itera sobre a Stream de entrada e chama a função de mapeamento para cada elemento.
Para cada elemento, a função de mapeamento retorna uma nova Stream de objetos.
Essas Streams são combinadas em uma única Stream de saída por meio da manipulação
de ponteiros.

Na prática, a implementação detalhada do método flatMap() da classe Stream é complexa
e depende de vários fatores, incluindo a implementação específica da JVM em que o
código está sendo executado, a configuração do sistema e o hardware subjacente.
No entanto, o resultado final é uma operação eficiente e flexível que pode ser usada
para transformar objetos em uma Stream em outros objetos em uma nova Stream em um
único passo.

---> Passo a Passo da implementação em LowLevel:

    1o - Iteração da Stream de entrada: O método flatMap() começa iterando a Stream
    de entrada, que contém os objetos que serão transformados.

    2o - Aplicação da função de mapeamento: Para cada elemento da Stream de entrada,
    a função de mapeamento é aplicada, produzindo uma nova Stream de objetos.
    Essa função é fornecida como argumento do método flatMap() e é responsável por
    transformar o objeto da Stream de entrada em uma nova Stream de objetos.

    3o - Concatenação das Streams resultantes: As Streams resultantes da aplicação
    da função de mapeamento são concatenadas em uma única Stream resultante.
    Isso é feito por meio da manipulação de ponteiros, que conectam as Streams
    resultantes.

    4o - Retorno da Stream resultante: A Stream resultante é retornada como saída
    do método flatMap().

Em resumo, o método flatMap() da classe Stream itera sobre a Stream de entrada,
aplica uma função de mapeamento a cada elemento e concatena as Streams resultantes
em uma única Stream de saída.
Esse processo permite transformar objetos em uma Stream em outros objetos em uma
nova Stream em um único passo, tornando o código mais conciso e eficiente.

---> SEM `flatMap()`:

    Stream<Stream<String>> streamStream = empresa.stream()
                .map(setor -> setor.stream());

    streamStream.forEach(setor -> setor
            .forEach(System.out::println));
    // Queremos transformar em Stream<String> apenas!


---> COM `flatMap()`: Reduzimos a quantidade de passos necessários para o mesmo resultado.

    // Solução: PORÉM ficar esperto pois vai ficar todos join no mesmo fluxo!!

    Stream<String> stringStream = empresa.stream()
            .flatMap(Collection::stream);

    stringStream.forEach(System.out::println);


---> As aplicações e utilidades do método flatMap() na classe Stream incluem:

    - Transformar uma Stream de objetos em outra Stream de objetos: O método
    flatMap() é usado para transformar objetos em uma Stream em outros objetos
    em uma nova Stream.
    Isso é particularmente útil quando se trabalha com listas aninhadas ou
    mapeamentos de valores.

    - Reduzir o número de passos em operações de transformação: O método flatMap()
    pode ser usado para realizar operações de transformação em uma única etapa,
    sem a necessidade de etapas intermediárias.

    - Simplificar operações de filtragem: O método flatMap() pode ser usado em
    conjunto com o método filter() para realizar operações de filtragem em uma
    única etapa.

    - Trabalhar com estruturas hierárquicas: O método flatMap() é especialmente
    útil ao trabalhar com dados que possuem uma estrutura hierárquica, como
    listas aninhadas ou mapeamentos de valores.


-------------------------------------------------------------------------------
---> Finding and Matching (Buscando elementos do fluxo de acordo com padrões):

- findFirst(): Retorna o PRIMEIRO elemento da sequência que atende a uma determinada
condição.
Se nenhum elemento for encontrado, ele retorna um objeto Optional vazio.
Aqui está um exemplo de como usá-lo:

    Optional<Integer> firstElement = Stream.of(1, 2, 3, 4, 5)
        .filter(n -> n % 2 == 0)
        .findFirst();

    O método filter() é usado para filtrar apenas os números pares da sequência,
    e o método findFirst() retorna o PRIMEIRO número par encontrado na sequência.


- findAny(): Retorna QUALQUER elemento da sequência que atenda a uma determinada
condição. (Não deterministico, ou seja é random of elements searched)
Se nenhum elemento for encontrado, ele retorna um objeto Optional vazio.
Aqui está um exemplo de como usá-lo:

    Optional<Integer> anyElement = Stream.of(1, 2, 3, 4, 5)
    .filter(n -> n % 2 == 0)
    .findAny();

    O método filter() é usado para filtrar apenas os números pares da sequência,
    e o método findAny() retorna QUALQUER número par encontrado na sequência.


- anyMatch(): Retorna true se pelo menos um elemento da sequência atende a uma
determinada condição.
Caso contrário, ele retorna false.
Aqui está um exemplo de como usá-lo:

    boolean anyMatch = Stream.of("apple", "banana", "cherry", "date")
    .anyMatch(fruit -> fruit.startsWith("b"));

    O método anyMatch() verifica se PELO MENOS UM elemento da sequência começa
    com a letra "b". Como "banana" atende a essa condição, o método retorna true.


- allMatch(): Retorna true se todos os elementos da sequência atenderem a uma
determinada condição.
Caso contrário, ele retorna false.
Aqui está um exemplo de como usá-lo:

    boolean allMatch = Stream.of("apple", "banana", "cherry", "date")
    .allMatch(fruit -> fruit.length() > 3);

    O método allMatch() verifica se TODOS os elementos da sequência têm mais de
    três caracteres. Como TODOS atendem a condição o método retorna true.


- noneMatch(): Retorna true se NENHUM elemento da sequência atender a uma determinada
condição.
Caso contrário, ele retorna false.
Aqui está um exemplo de como usá-lo:

    boolean noneMatch = Stream.of("apple", "banana", "cherry", "date")
    .noneMatch(fruit -> fruit.startsWith("z"));

    O método noneMatch() verifica se nenhum elemento da sequência começa com a
    letra "z". Como nenhum elemento atende a essa condição, o método retorna true.


-------------------------------------------------------------------------------
---> `reduce()` Utilizado para unir/reduzir elementos do fluxo em um único valor.
- Assinatura: Optional<T> reduce(BinaryOperator<T> accumulator);

O método reduce() é um dos métodos mais poderosos da API Streams.
Ele é usado para reduzir uma sequência de elementos a um único elemento, aplicando
uma operação associativa aos elementos da sequência.

A operação associativa é uma operação que pode ser aplicada a DOIS elementos
quaisquer da sequência, e cujo resultado pode ser combinado com o resultado da
operação aplicada a outros elementos da sequência.
Por exemplo, a soma e a multiplicação são operações associativas, enquanto a
subtração e a divisão não são.


---> Operação ASSOCIATIVA na matemática:
(Resumo: Transitividade aonde 2 + 1 é o msm que 1 + 2);
Ou seja, "A ordem dos fatores não altera o produto";
Poréeeem, não é bem assim pois strings a ordem altera sim
    Exemplo: "hellow" e  "word" em operação de concatenação == wordhellow

É uma propriedade matemática que significa que o resultado de uma operação binária
(isto é, que envolve dois elementos) é o mesmo, independentemente da ordem em que
os elementos são processados.
Por exemplo, para uma operação associativa "op", o seguinte é verdadeiro:

    (a op b) op c = a op (b op c) --> (aonde op é +, -, /, *..)

Em outras palavras, se você aplicar a operação "op" aos elementos "a" e "b",
e depois aplicá-la ao resultado e "c", o resultado final será o mesmo que se
você aplicasse "op" aos elementos "b" e "c" primeiro, e depois aplicasse "op"
ao resultado e "a".

- SÃO Operações Associativas:
A SOMA e a MULTIPLICAÇÃO são operações associativas porque a ordem em que se
adicionam ou multiplicam números não afeta o resultado final.
Por exemplo:

    2 + 3 + 4 é o mesmo que 4 + 2 + 3, e 2 * 3 * 4 é o mesmo que 4 * 2 * 3.

- NÃO são Operações Associativas:
Já a subtração e a divisão não são operações associativas porque a ordem em que
se subtraem ou dividem números pode afetar o resultado final.
Por exemplo:

    (10 - 5) - 3 é diferente de 10 - (5 - 3), e (20 / 5) / 2 é diferente de 20 / (5 / 2).


- A propriedade de associatividade é importante no contexto do método reduce()
da API Streams, porque a função binária que é usada como argumento deve ser
associativa para que o resultado seja o mesmo, independentemente da ordem em que
os elementos são processados.
Se a função binária não for associativa, o resultado final do método reduce()
pode ser diferente, dependendo da ordem em que os elementos são processados.

O método reduce() recebe como argumento uma função binária que implementa a
operação associativa, e retorna um Optional que contém o resultado da operação.
O resultado pode ser um objeto de qualquer tipo, desde que a operação seja
definida para esse tipo.


---> Algumas aplicações e utilidades do método reduce() incluem:

    - Somar os elementos de uma sequência de números:

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        int sum = numbers.stream().reduce(0, (x, y) -> x + y);
        System.out.println(sum); // imprime 15

        ou também podemos utilizar method reference:
        numbers.stream().reduce(Integer::sum).ifPresent(System.out::println);


    - Multiplicar os elementos de uma sequência de números:

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        int product = numbers.stream().reduce(1, (x, y) -> x * y);
        System.out.println(product); // imprime 120

    - Encontrar o maior elemento de uma sequência:

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Optional<Integer> max = numbers.stream().reduce(Integer::max);
        System.out.println(max.get()); // imprime 5

        obs: poderia utilizar o método max() ao invés do reduce.

    - Concatenar os elementos de uma sequência de strings:

        List<String> words = Arrays.asList("foo", "bar", "baz");
        String concatenated = words.stream().reduce("", (a, b) -> a + b);
        System.out.println(concatenated); // imprime "foobarbaz"


---> O reduce() recebe BinaryOperator<T> accumulator, quais outros tipos?

O Java possui diversos tipos de BinaryOperator, que são interfaces funcionais que
representam uma operação binária entre dois operandos do mesmo tipo, produzindo
um resultado do mesmo tipo.

- Obs: Todos são Interfaces Funcionais

- Segue abaixo uma lista dos principais tipos de BinaryOperator:

    - BinaryOperator<T>: É a interface mais genérica de BinaryOperator.
    Ela representa uma operação binária entre dois operandos do tipo T,
    produzindo um resultado do tipo T.

    - DoubleBinaryOperator: Representa uma operação binária entre dois valores
    do tipo double, produzindo um resultado do tipo double.

    - IntBinaryOperator: Representa uma operação binária entre dois valores do
    tipo int, produzindo um resultado do tipo int.

    - LongBinaryOperator: Representa uma operação binária entre dois valores do
    tipo long, produzindo um resultado do tipo long.


-------------------------------------------------------------------------------
---> Trabalhando com Tipos primitivos numéricos com Stream personalizados,
evitando assim overhead, autoBoxing e unBoxing dos Wrappers numéricos em looping
ganhando mais performance em alguns casos.

- Streams personalizados para:
    - IntStream;
    - LongStream;
    - DoubleStream;

- Obs: Também é possível transformar/converter esses fluxos Streams Personalizados em
Streams genéricos, fazendo boxing de um para outro caso necessário utilizando o método
`boxed()`;

Uma das principais utilidades das classes especializadas é que elas evitam a
necessidade de criar objetos wrapper para tipos primitivos, como Integer ou
Double, quando se trabalha com coleções de dados.
Isso é importante porque a criação de objetos pode ser um processo custoso em
termos de desempenho, especialmente em coleções grandes.

Além disso, as classes especializadas fornecem uma série de métodos especializados
para operações matemáticas e estatísticas, como média, soma, máximo, mínimo, entre
outras. Esses métodos são projetados para trabalhar com dados numéricos de forma
eficiente e são mais expressivos do que a utilização de métodos genéricos em uma
coleção de objetos.

As classes especializadas também fornecem métodos para converter coleções de dados
numéricos em outros tipos de dados, como arrays ou outras coleções.
Isso pode ser útil em muitos cenários, como quando se trabalha com bibliotecas ou
APIs que esperam determinados tipos de dados.

Em resumo, as classes especializadas para tipos primitivos na API Streams oferecem
uma maneira mais eficiente e expressiva de trabalhar com coleções de dados numéricos,
fornecendo métodos especializados para manipulação de dados e operações matemáticas.
Isso pode levar a um código mais limpo e eficiente em termos de desempenho,
especialmente em cenários onde é necessário lidar com grandes conjuntos de dados
numéricos.

---> Como utilizar?
Para utilizar, basta converter/transformar o fluxo Stream em questão utilizando os
métodos `mapToInt(Coleção::getAtributInt)` ou `mapToLong(Coleção::getAtributLong)`
ou `mapToDouble(Coleção::getAtributDouble)`;

- Obs: Isso irá "descartar" o Objeto elemento do fluxo e irá retornar apenas no
novo Stream Personalizado os valores contidos no `getAtribut..`, pois agora
não estamos mais trabalhando com o Objeto por completo do fluxo anterior e sim
mapeando em um novo fluxo algum campo numérico desse Objeto em questão.

- SEM Stream personalizado: NÃO INDICADO! ;-;

    listOfLightNovels.stream()
            .filter(novel -> novel.getPrice() > 3)
            .map(LightNovelModel::getPrice) // Stream<Double>
            .reduce(Double::sum)
            .ifPresent(System.out::println); // 15.8

    // Observe que utilizando `map()` comum o retorno será Stream<Double>
    // ou seja, neste contexto vai rolar autoBoxing e unBoxing durante as
    // operações subsequentes.


- COM Stream personalizada: INDICADO! ;D

    double sum = listOfLightNovels.stream()
            .mapToDouble(LightNovelModel::getPrice) // DoubleStream
            .filter(price -> price > 3)
            .sum();
    System.out.println(sum); // 15.8


- Convertendo DoubleStream para Stream<Double>:
Util quando algum método subjacente espera um Wrapper ao invés de primitivo.
Exemplo: Adicionar os valores numéricos em uma coleção de Double:

    List<Double> listOfPricesGreatThan3 = listOfLightNovels.stream()
          .mapToDouble(LightNovelModel::getPrice) // DoubleStream
          .filter(price -> price > 3)
          .boxed() // Transforma o fluxo personalizado em genérico DoubleStream <=> Stream<Double>
          .collect(Collectors.toList()); // Pois o List<> espera um Objeto Wrapper, não tipo primitivo.

    listOfPricesGreatThan3.forEach(System.out::println);


---> O que é OverHead?

Overhead é um termo utilizado para descrever a quantidade de recursos (como tempo
de processamento, memória ou largura de banda) que são consumidos por um determinado
processo, atividade ou operação, além do necessário para realizar sua tarefa principal.

Em outras palavras, overhead é a sobrecarga adicional que é colocada sobre um sistema
ou processo para realizar tarefas que não são diretamente relacionadas com a sua
finalidade principal.
Por exemplo, a sobrecarga de processamento que é colocada sobre um sistema quando
ele executa um antivírus em segundo plano, enquanto o usuário executa outras tarefas.

O overhead pode ser causado por uma variedade de fatores, como a necessidade de
realizar verificações de segurança adicionais, a alocação de memória para armazenar
informações adicionais ou a execução de operações adicionais para manter a integridade
de um sistema. Ele pode afetar a eficiência e o desempenho de um sistema, bem como o
consumo de recursos, como espaço em disco ou tempo de processamento.


-------------------------------------------------------------------------------
---> Gerando fluxos Streams apartir das classes Streams Personalizadas e etc:
- Streams contendo ranges de valores inteiros;
- Streams contendo ranges do alfabeto;
- Streams contendo Strings ou qualquer outros Objetos <T>;
- Gerando Streams Apartir de arrays nativos;
- Gerando Streams Apartir de arquivos com `Files`;


---> Gerando range de valores inteiros:
Existem dois métodos que geram ranges de valores, sendo eles:
`range(startInclusive, endExclusive)` e `rangeClosed(startInclusive, endInclusive)`

     IntStream.range(0, 21) // de 0 a 20
            .filter(n -> n % 2 == 0)
            .forEach(n -> System.out.print(n + ", "));
    // 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,

    - A diferença de um para outro é se vai considerar o valor final do range.


---> MACETE para gerar Strings do alfabeto com IntStream que represente ASCII:

        IntStream.range('a', 'z'+1)
                .mapToObj(Character::toString)
                .forEach(letra -> System.out.print(letra + ", "));
        // a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z,

O método range() gera uma sequência de inteiros começando em 'a' e terminando em
'z' + 1, que corresponde ao código ASCII da letra 'z mais um.
Em seguida, o método mapToObj() é usado para mapear cada valor inteiro para uma
String usando o método Character.toString().


---> Gerando Streams de String ou qualquer outro Objeto <T>:

   Stream.of("Wellison","wesley", "Irineu", "InemEu")
            .filter(string -> string.toUpperCase().startsWith("W") && string.length() > 7)
            .forEach(string -> System.out.print(string + ", "));
        // Wellison,


---> Gerando Streams Apartir de arrays nativos:

    int[] numbersArrayNativo = {1, 2, 3, 4, 5, 6};

    Arrays.stream(numbersArrayNativo)
            .average()
            .ifPresent(System.out::println); // 3.5


---> Gerando Streams Apartir de Arquivos com `Files`:

    try(Stream<String> lines = Files.lines(Paths.get("src/nio/SimpleFileVisitor_listaArquivosMaioresQue1GB.txt"))) {
        lines.filter(line -> line.startsWith("R"))
                .forEach(System.out::println);
        // Rick and Morty S06E10 WEB-DL 1080p DUAL 5.1.mkv
        // Rick.and.Morty.S06E09.1080p.WEB-DL.DUAL.5.1.mkv
        // Rick.and.Morty.S06E08.1080p.WEB-DL.DUAL.5.1.mkv
        // Rick.and.Morty.S06E07.1080p.WEB-DL.DUAL.mkv
        // Rick.and.Morty.S06E06.1080p.WEB-DL.DUAL.mkv


        // Se contem alguma string em qualquer lugar:
        lines.filter(line -> line.contains("1080p"))
                .forEach(System.out::println);

    } catch (IOException ex) {
        ex.printStackTrace();
    }


-------------------------------------------------------------------------------
---> Gerando Streams Infinitos com Iterate e Generate (Sequencia de Fibonacci):

---> Sequencia de Fibonacci: (0,1) (1,1) (1,2) (2,3) (3,5) (5,8) (8,13)
Aonde a posição 0 do atual sempre é a posição 1 do anterior:

    Stream.iterate(new int[]{0, 1}, n -> new int[]{n[1], n[0] + n[1]})
            .limit(10)
            .forEach(a -> System.out.print(Arrays.toString(a) + " "));
    // [0, 1] [1, 1] [1, 2] [2, 3] [3, 5] [5, 8] [8, 13] [13, 21] [21, 34] [34, 55]

    // Mesma coisa porém retornando apenas os valores da sequencia:
    Stream.iterate(new int[]{0, 1}, n -> new int[]{n[1], n[0] + n[1]})
            .limit(10)
            .map(a -> a[0])
            .forEach(val -> System.out.print(val + ", "));
    // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34,


---> Os 10 Primeiros impares:

     Stream.iterate(1, n -> n + 2)
            .limit(10)
            .forEach(n -> System.out.print(n + ", "));
    // 1, 3, 5, 7, 9, 11, 13, 15, 17, 19,


---> Gerando números aleatórios:

    ThreadLocalRandom random = ThreadLocalRandom.current();
    Stream.generate(() -> random.nextInt(1, 1000))
            .limit(10)
            .forEach(n -> System.out.print(n + ", "));
    // 782, 837, 295, 485, 233, 281, 251, 728, 310, 112,

-------------------------------------------------------------------------------
---> Operações finais com Collectors: Operações Agregadas com `Summarizing`:
- COUNT: Conta número de ocorrências/elementos do fluxo (Rows);
- SUM: Soma todos elementos do fluxo;
- MIN: Retorna o menor< elemento (de acordo com Comparator) do fluxo;
- AVG: Retorna a média dos elementos;
- MAX: Retorna o maior> elemento (de acordo com Comparator) do fluxo;

- Summarizing (Sumário contendo um resumo com todas operações anteriores em um);


---> Para que serve a classe Collectors?

É uma classe utilitária que fornece vários métodos estáticos para coletar
elementos de um stream em uma coleção ou um valor único.

Os métodos da classe Collectors são usados para criar uma instância de Collector,
que define como os elementos de um stream devem ser coletados. Um Collector
especifica uma operação de redução, que pode ser usada para combinar todos os
elementos de um stream em uma coleção ou um valor único.

---> Métodos mais Uteis do Collectors:

- toList(): Retorna uma lista que contém todos os elementos do stream.

- toSet(): Retorna um conjunto que contém todos os elementos do stream,
sem duplicatas.

- toMap(): Retorna um mapa que contém pares chave-valor dos elementos do
stream, onde a chave e o valor são especificados por funções de mapeamento.

- joining(): Retorna uma string contendo a concatenação de todos os elementos
do stream, separados por um delimitador especificado.

- counting(): Retorna o número de elementos no stream como um valor long.

- minBy(): Retorna o menor elemento do stream com base em um comparador
especificado.

- maxBy(): Retorna o maior elemento do stream com base em um comparador
especificado.

- averagingInt(), averagingDouble(), averagingLong(): Retorna a média dos
valores inteiros, de ponto flutuante ou longos do stream.

- summingInt(), summingDouble(), summingLong(): Retorna a soma dos valores
inteiros, de ponto flutuante ou longos do stream.

- partitioningBy(): Retorna um mapa que contém as partições dos elementos
do stream de acordo com um predicado especificado.

- groupingBy(): Retorna um mapa que contém os elementos do stream agrupados
de acordo com uma função de agrupamento especificada.

- reducing(): Retorna um coletor que executa uma redução sequencial dos
elementos do stream, com base em uma operação binária especificada.

- mapping(): Retorna um coletor que aplica uma função de mapeamento aos
elementos do stream antes de coletá-los.

- teeing(): Retorna um coletor que permite agrupar resultados de dois coletores
independentes em um terceiro resultado.

- toCollection(): Retorna uma coleção especificada pelo usuário que contém todos
os elementos do stream.

- toConcurrentMap(): Retorna um mapa que contém pares chave-valor dos elementos
do stream, onde a chave e o valor são especificados por funções de mapeamento,
e que pode ser usado com segurança em threads concorrentes.

- toUnmodifiableList(), toUnmodifiableSet(), toUnmodifiableMap(): Retorna uma
lista, conjunto ou mapa que contém os elementos do stream, mas que não pode
ser modificado.

- summarizingInt(), summarizingDouble(), summarizingLong(): Retorna um objeto
de resumo que contém estatísticas como a soma, média, mínimo e máximo dos
valores inteiros, de ponto flutuante ou longos do stream.

- filtering(): Retorna um coletor que aplica um filtro a elementos do stream
antes de coletá-los.


---> COUNT (Contando quantidade de ocorrências/elementos):

    // Trabalhando com primitivo:
    long count = listOfLightNovels.stream()
            .count();

    // Trabalhando com Wrapper:
    Long countWithCollectors = listOfLightNovels.stream()
            .collect(Collectors.counting());

    - Output: 5


---> SUM (Somando todos elementos do fluxo):
- Obs: Evitando autoBoxing e unBoxing com mapToDouble:

    // Trabalhando com primitivo:
    double sum = listOfLightNovels.stream()
            .mapToDouble(LightNovelModel::getPrice)
            .sum();

    // Trabalhando com Wrapper:
    Double sumWithCollectors = listOfLightNovels.stream()
            .collect(Collectors.summingDouble(LightNovelModel::getPrice));

    - Outpout: 17.8


---> MIN (Retornando o menor< elemento do fluxo de acordo com Comparator):
Obs: returns Optional:

    listOfLightNovels.stream()
            .min(Comparator.comparing(LightNovelModel::getPrice))
            .ifPresent(System.out::println);

    listOfLightNovels.stream()
            .collect(Collectors.minBy(Comparator.comparing(LightNovelModel::getPrice)))
            .ifPresent(System.out::println);

    - Output: LightNovelModel{title='Tokyo Ghoul', price=2.0}


---> AVARAGE (Retornando a média dos elementos do fluxo):

    listOfLightNovels.stream()
            .mapToDouble(LightNovelModel::getPrice)
            .average()
            .ifPresent(System.out::println);

    Double avgWithCollectors = listOfLightNovels.stream()
            .collect(Collectors.averagingDouble(LightNovelModel::getPrice));

    - Output: 3.56


---> MAX (Retornando o maior> elemento do fluxo de acordo com Comparator):
Obs: returns Optional:

    listOfLightNovels.stream()
            .max(Comparator.comparing(LightNovelModel::getPrice))
            .ifPresent(System.out::println);

    listOfLightNovels.stream()
            .collect(Collectors.maxBy(Comparator.comparing(LightNovelModel::getPrice)))
            .ifPresent(System.out::println);

    - Output: LightNovelModel{title='Dragon Ball', price=5.2}


---> Summarizing (Todas operações anteriores em apenas uma):
Obs: Sumário/resumo, com todas essas operações agregadas em apenas um Objeto/operação:
Porém ele trás apenas os valores, ou seja não é possível analisar o Objeto no qual é
referente! exemplo: minimo é o LightNovelModel{title='Tokyo Ghoul', price=2.0}
porém ele trás apenas o valor 2.0, não faz referência ao objeto por completo.

    DoubleSummaryStatistics sumario = listOfLightNovels.stream()
            .collect(Collectors.summarizingDouble(LightNovelModel::getPrice));

    - Output: DoubleSummaryStatistics{count=5, sum=17,800000, min=2,000000, average=3,560000, max=5,200000}


---> Concatenando Strings:
Obs: Não coloca o delimitador no último elemento, detalhe que se fosse implementar
na unha teriamos que fazer verificações se chegou no último elemento para assim
não colocar nele a ", " por exemplo.

    String concatStringWithCollectors = listOfLightNovels.stream()
            .map(LightNovelModel::getTitle)
            .collect(Collectors.joining(", "));

    - Output: Tokyo Ghoul, KissXKiss, Dragon Ball, Danielle, Welzika


-------------------------------------------------------------------------------
